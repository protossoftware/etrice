/**
 * @author generated by eTrice
 *
 * Source File of ActorClass ATimingService
 * 
 */

#include "ATimingService.h"
#include "common/debugging/DebuggingService.h"
#include <iostream>

using namespace etRuntime;


ATimingService::ATimingService(etRuntime::IRTObject* parent, std::string name, const std::vector<std::vector<etRuntime::Address> >& port_addr, 
 						  											 const std::vector<std::vector<etRuntime::Address> >& peer_addr)
:  ActorClassBase( parent, name, port_addr[0][0], peer_addr[0][0]),
timer(*this, this, "timer", IFITEM_timer, port_addr[IFITEM_timer], peer_addr[IFITEM_timer]),
tcbs(),
usedTcbsRoot(0),
freeTcbsRoot(0)
{
	history = new int[s_numberOfStates];
	for (int i = 0; i < s_numberOfStates; i++) {
		history[i] = NO_STATE;
	}
	setClassName("ATimingService");
	// initialize attributes
	for (int i=0;i<10;i++){
		tcbs[i] = etTimerControlBlock();
	}

	getMsgsvc()->addAsyncActor(*this);
}

void ATimingService::init(){
	initUser();
}
	
void ATimingService::start(){
	startUser();
}
	
void ATimingService::stop(){
	stopUser();
}

void ATimingService::destroy(){
}


std::string ATimingService::s_stateStrings[] = {"<no state>","<top>","Operational"
};
const int ATimingService::s_numberOfStates = 3;

void ATimingService::setState(int new_state) {
	DebuggingService::getInstance().addActorState(*this, s_stateStrings[new_state]);
	if (s_stateStrings[new_state]!="Idle") {
		std::cout << getInstancePath() << " -> " << s_stateStrings[new_state] << std::endl;
	}	
	m_state = new_state;
}

/* Entry and Exit Codes */
void ATimingService::entry_Operational() {
	// prepare
}
 void ATimingService::do_Operational() {
	// maintain timers
	etTimerControlBlock* temp;
	etTargetTime_t t;
	
	getTimeFromTarget(&t);
	while (usedTcbsRoot !=0 ){
		if (isTimeGreater(&t,&(usedTcbsRoot->expTime))){
			timer.get(usedTcbsRoot->portIdx).timeout();
			temp=usedTcbsRoot;
			usedTcbsRoot=usedTcbsRoot->next;
			if((temp->pTime.sec==0)&&(temp->pTime.nSec==0)){
				// single shot timer
				returnTcb(temp);
			}else{
				// periodic timer
				addTime(&temp->expTime,&temp->pTime);
				putTcbToUsedList(temp);
				}
			}else{
				break;
				}
		}
}

/* Action Codes */
void ATimingService::action_TRANS_INITIAL_TO__Operational() {
	int i;
	usedTcbsRoot=0;
	freeTcbsRoot=&tcbs[0];
	tcbs[ET_NB_OF_TCBS-1].next=0;
	for (i=0;i<ET_NB_OF_TCBS-1;i++){
		tcbs[i].next=&tcbs[i+1];
		}
}
void ATimingService::action_TRANS_tr1_FROM_Operational_TO_Operational_BY_startTimeouttimer_tr1(const InterfaceItemBase* ifitem, uint32 time) {
	etTimerControlBlock* timer = getTcb();
	etTargetTime_t t;
	if (timer!= 0){
		t.sec=time/1000;
		t.nSec=(time%1000)*1000000L;
		timer->pTime.sec = 0;
		timer->pTime.nSec = 0;
		timer->portIdx=ifitem->getIdx();
		getTimeFromTarget(&(timer->expTime));
		addTime(&(timer->expTime),&t);
		putTcbToUsedList(timer);
		}
}
void ATimingService::action_TRANS_tr3_FROM_Operational_TO_Operational_BY_startTimertimer_tr3(const InterfaceItemBase* ifitem, uint32 time) {
	etTimerControlBlock* timer = getTcb();
	etTargetTime_t t;
	if (timer!= 0){
		t.sec=time/1000;
		t.nSec=(time%1000)*1000000L;
		timer->pTime = t;
		timer->portIdx=ifitem->getIdx();
		getTimeFromTarget(&(timer->expTime));
		addTime(&(timer->expTime),&t);
		putTcbToUsedList(timer);
		}
}
void ATimingService::action_TRANS_tr4_FROM_Operational_TO_Operational_BY_killtimer_tr4(const InterfaceItemBase* ifitem) {
	removeTcbFromUsedList(ifitem->getIdx());
}

/**
 * calls exit codes while exiting from the current state to one of its
 * parent states while remembering the history
 * @param current - the current state
 * @param to - the final parent state
 * @param handler - entry and exit codes are called only if not handler (for handler TransitionPoints)
 */
void ATimingService::exitTo(int current, int to, bool handler) {
	while (current!=to) {
		switch (current) {
			case STATE_Operational:
				this->history[STATE_TOP] = STATE_Operational;
				current = STATE_TOP;
				break;
		}
	}
}

/**
 * calls action, entry and exit codes along a transition chain. The generic data are cast to typed data
 * matching the trigger of this chain. The ID of the final state is returned
 * @param chain - the chain ID
 * @param generic_data - the generic data pointer
 * @return the ID of the final state
 */
int ATimingService::executeTransitionChain(int chain, const InterfaceItemBase* ifitem, void* generic_data) {
	switch (chain) {
		case CHAIN_TRANS_INITIAL_TO__Operational:
		{
			action_TRANS_INITIAL_TO__Operational();
			return STATE_Operational;
		}
		case CHAIN_TRANS_tr1_FROM_Operational_TO_Operational_BY_startTimeouttimer_tr1:
		{
			uint32 time = ((uint32) generic_data);
			action_TRANS_tr1_FROM_Operational_TO_Operational_BY_startTimeouttimer_tr1(ifitem, time);
			return STATE_Operational;
		}
		case CHAIN_TRANS_tr3_FROM_Operational_TO_Operational_BY_startTimertimer_tr3:
		{
			uint32 time = ((uint32) generic_data);
			action_TRANS_tr3_FROM_Operational_TO_Operational_BY_startTimertimer_tr3(ifitem, time);
			return STATE_Operational;
		}
		case CHAIN_TRANS_tr4_FROM_Operational_TO_Operational_BY_killtimer_tr4:
		{
			action_TRANS_tr4_FROM_Operational_TO_Operational_BY_killtimer_tr4(ifitem);
			return STATE_Operational;
		}
	}
	return NO_STATE;
}

/**
 * calls entry codes while entering a state's history. The ID of the final leaf state is returned
 * @param state - the state which is entered
 * @param handler - entry code is executed if not handler
 * @return - the ID of the final leaf state
 */
int ATimingService::enterHistory(int state, bool handler, bool skip_entry) {
	while (true) {
		switch (state) {
			case STATE_Operational:
				if (!(skip_entry || handler)) entry_Operational();
				// in leaf state: return state id
				return STATE_Operational;
			case STATE_TOP:
				state = this->history[STATE_TOP];
				break;
		}
		skip_entry = false;
	}
	//return NO_STATE; // required by CDT but detected as unreachable by JDT because of while (true)
}

void ATimingService::executeInitTransition() {
	int chain = CHAIN_TRANS_INITIAL_TO__Operational;
	int next = ATimingService::executeTransitionChain(chain, 0, 0);
	next = ATimingService::enterHistory(next, false, false);
	setState(next);
}

/* receiveEvent contains the main implementation of the FSM */
void ATimingService::receiveEvent(InterfaceItemBase* ifitem, int evt, void* generic_data) {
	int trigger = (ifitem==0)? POLLING : ifitem->getLocalId() + EVT_SHIFT*evt;
	int chain = NOT_CAUGHT;
	int catching_state = NO_STATE;
	bool is_handler = false;
	bool skip_entry = false;
	
	if (!handleSystemEvent(ifitem, evt, generic_data)) {
		switch (getState()) {
			case STATE_Operational:
				switch(trigger) {
				case POLLING:
					do_Operational();
					break;
					case TRIG_timer__startTimeout:
						{
							chain = CHAIN_TRANS_tr1_FROM_Operational_TO_Operational_BY_startTimeouttimer_tr1;
							catching_state = STATE_TOP;
						}
					break;
					case TRIG_timer__startTimer:
						{
							chain = CHAIN_TRANS_tr3_FROM_Operational_TO_Operational_BY_startTimertimer_tr3;
							catching_state = STATE_TOP;
						}
					break;
					case TRIG_timer__kill:
						{
							chain = CHAIN_TRANS_tr4_FROM_Operational_TO_Operational_BY_killtimer_tr4;
							catching_state = STATE_TOP;
						}
					break;
				}
				break;
		}
	}
	if (chain != NOT_CAUGHT) {
		ATimingService::exitTo(getState(), catching_state, is_handler);
		int next = ATimingService::executeTransitionChain(chain, ifitem, generic_data);
		next = ATimingService::enterHistory(next, is_handler, skip_entry);
		setState(next);
	}
}
	 
//******************************************
// END of generated code for FSM
//******************************************
