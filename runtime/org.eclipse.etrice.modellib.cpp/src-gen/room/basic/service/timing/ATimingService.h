/**
 * @author generated by eTrice
 *
 * Header File of ActorClass ATimingService
 *
 */

#ifndef _ROOM_BASIC_SERVICE_TIMING_ATIMINGSERVICE_H_
#define _ROOM_BASIC_SERVICE_TIMING_ATIMINGSERVICE_H_

#include "common/etDatatypesCpp.hpp"
#include "common/messaging/IRTObject.h"
#include "common/modelbase/PortBase.h"
#include "common/modelbase/ReplicatedActorClassBase.h"
#include "common/modelbase/InterfaceItemBase.h"
#include "common/modelbase/SubSystemClassBase.h"
#include "common/messaging/Address.h"
#include "common/messaging/IMessageReceiver.h"
#include "common/debugging/DebuggingService.h"

#include "room/basic/service/timing/PTimer.h"

#include "common/modelbase/ActorClassBase.h"

/*--------------------- begin user code ---------------------*/
#include "osal/etTime.h" 
#define ET_NB_OF_TCBS 30
typedef struct etTCB etTimerControlBlock;
struct etTCB {
	etTime expTime;
	etTime pTime;
	int32 portIdx;
	etTimerControlBlock* next;
};

/*--------------------- end user code ---------------------*/

using namespace etRuntime;


class ATimingService : public etRuntime::ActorClassBase {


	protected:
		//--------------------- ports

		//--------------------- sub actors

		//--------------------- saps

		//--------------------- services
		PTimerReplPort timer;

		//--------------------- interface item IDs
		typedef enum {
			IFITEM_timer = 1
		} interface_items;

		/*--------------------- attributes ---------------------*/
		 StaticArray<etTimerControlBlock, 30> tcbs;
		 etTimerControlBlock* usedTcbsRoot;
		 etTimerControlBlock* freeTcbsRoot;

		/*--------------------- operations ---------------------*/
		 etTimerControlBlock* getTcb();
		 void returnTcb(etTimerControlBlock* block);
		 void removeTcbFromUsedList(int32 idx);
		 void putTcbToUsedList(etTimerControlBlock* block);
		 bool isTimeGreater(etTime* t1, etTime* t2);
		 void addTime(etTime* t1, etTime* t2);

	public:
		//--------------------- construction
		ATimingService(etRuntime::IRTObject* parent, const String& name);
		void initialize(void);
		void setProbesActive(bool recursive, bool active);

		//--------------------- port getters


		PTimerReplPort& getTimer (){
			return this->timer;
		}

		//--------------------- lifecycle functions
		virtual void destroy();

		/* state IDs */
		typedef enum {
			STATE_Operational = 2,
			STATE_MAX = 3
		} state_ids;
		
		/* transition chains */
		typedef enum {
			CHAIN_TRANS_INITIAL_TO__Operational = 1,
			CHAIN_TRANS_tr1_FROM_Operational_TO_Operational_BY_startTimeouttimer_tr1 = 2,
			CHAIN_TRANS_tr3_FROM_Operational_TO_Operational_BY_startTimertimer_tr3 = 3,
			CHAIN_TRANS_tr4_FROM_Operational_TO_Operational_BY_killtimer_tr4 = 4
		} ChainIDs;
		
		/* triggers */
		typedef enum {
			POLLING = 0,
			TRIG_timer__startTimer = IFITEM_timer + EVT_SHIFT*PTimer::IN_startTimer,
			TRIG_timer__startTimeout = IFITEM_timer + EVT_SHIFT*PTimer::IN_startTimeout,
			TRIG_timer__kill = IFITEM_timer + EVT_SHIFT*PTimer::IN_kill
		} triggers;

		static const String s_stateStrings[];
		static const int s_numberOfStates;
		
		int history[3];
		
		void setState(int new_state);
		
		/* Entry and Exit Codes */
		virtual void entry_Operational();
		virtual void do_Operational();
		
		/* Action Codes */
		virtual void action_TRANS_INITIAL_TO__Operational();
		virtual void action_TRANS_tr1_FROM_Operational_TO_Operational_BY_startTimeouttimer_tr1(const InterfaceItemBase* ifitem, uint32 transitionData);
		virtual void action_TRANS_tr3_FROM_Operational_TO_Operational_BY_startTimertimer_tr3(const InterfaceItemBase* ifitem, uint32 transitionData);
		virtual void action_TRANS_tr4_FROM_Operational_TO_Operational_BY_killtimer_tr4(const InterfaceItemBase* ifitem);
		
		/* State Switch Methods */
		/**
		 * calls exit codes while exiting from the current state to one of its
		 * parent states while remembering the history
		 * @param current__et - the current state
		 * @param to - the final parent state
		 */
		void exitTo(etInt16 current__et, etInt16 to);
		
		/**
		 * calls action, entry and exit codes along a transition chain. The generic data are cast to typed data
		 * matching the trigger of this chain. The ID of the final state is returned
		 * @param chain__et - the chain ID
		 * @param generic_data__et - the generic data pointer
		 * @return the +/- ID of the final state either with a positive sign, that indicates to execute the state's entry code, or a negative sign vice versa
		 */
		etInt16 executeTransitionChain(int chain__et, const InterfaceItemBase* ifitem, void* generic_data__et);
		
		/**
		 * calls entry codes while entering a state's history. The ID of the final leaf state is returned
		 * @param state__et - the state which is entered
		 * @return - the ID of the final leaf state
		 */
		etInt16 enterHistory(etInt16 state__et);
		
		void executeInitTransition();
		
		/* receiveEvent contains the main implementation of the FSM */
		void receiveEventInternal(InterfaceItemBase* ifitem, int localId, int evt, void* generic_data__et);
		void receiveEvent(InterfaceItemBase* ifitem, int evt, void* generic_data__et);
		virtual void receive(const etRuntime::Message* msg);

		/*--------------------- begin user code ---------------------*/
		// uc2
		/*--------------------- end user code ---------------------*/

};

class ReplicatedATimingService : public ReplicatedActorClassBase {
public:
	ReplicatedATimingService(IRTObject* parent, const String& name) :
		ReplicatedActorClassBase(parent, name) {}
	
protected:
	ActorClassBase* createActor(IRTObject* parent, const String& name) {
		return new ATimingService(parent, name);
	}
};


#endif /* _ROOM_BASIC_SERVICE_TIMING_ATIMINGSERVICE_H_ */
