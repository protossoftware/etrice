RoomModel TrafficLight {

	import room.basic.service.timing.* from "../../../org.eclipse.etrice.modellib.c/model/TimingService.room"

	import room.basic.service.tcp.* from "../../../org.eclipse.etrice.modellib.c/model/TcpService.room"

	import room.basic.types.* from "../../../org.eclipse.etrice.modellib.c/model/Types.room"

	LogicalSystem TrafficLight {
//		SubSystemRef subSystem: TrafficLightStep1_Test
//		SubSystemRef subSystem: TrafficLightStep2_SingleTrafficLight
		SubSystemRef subSystem: TrafficLightStep3_MultipleTrafficLights
	}

	SubSystemClass TrafficLightStep1_Test {
		ActorRef step1_TestApplication: TestApplication
		ActorRef timingService: ATimingService
		LayerConnection ref step1_TestApplication satisfied_by timingService.timer
		LogicalThread defaultThread
	}

	SubSystemClass TrafficLightStep2_SingleTrafficLight {
		ActorRef timingService: ATimingService
		ActorRef step2_SingleTrafficLight: SingleTrafficLight
		LayerConnection ref step2_SingleTrafficLight satisfied_by timingService.timer
		LogicalThread defaultThread
	}

	SubSystemClass TrafficLightStep3_MultipleTrafficLights {
		ActorRef timingService: ATimingService
		ActorRef step3_FlatReplication: FlatReplication
		ActorRef step4_HierarchicalReplication: HierarchicalReplication
		LayerConnection ref step3_FlatReplication satisfied_by timingService.timer
		LayerConnection ref step4_HierarchicalReplication satisfied_by timingService.timer
		LogicalThread defaultThread
	}

	ActorClass TestApplication ["The TestApplication contains the PedestrianTrafficLightController and its test harness."] {
		Structure {
			ActorRef controller: PedestrianTrafficLightController
			ActorRef controllerTestHarness: TrafficLightControllerTestHarness
			Binding controllerTestHarness.fct and controller.fct
			Binding controller.tlInterface and controllerTestHarness.tlInterface
		}
		Behavior { }
	}

	ActorClass SingleTrafficLight ["OneTrafficLight contains the PedestrianTrafficLightController which is connected via a SocketClient Actor to the traffic light GUI."] {
		Structure {
			ActorRef controller: PedestrianTrafficLightController
			ActorRef headquarters1: TrafficLightHeadquarters
			ActorRef tlInterface: TrafficLightInterface
			Binding headquarters1.controllers and controller.fct
			Binding controller.tlInterface and tlInterface.fct
		}
		Behavior { }
	}

	ActorClass FlatReplication ["FlatReplication uses several replicated Actors in a row to control 2 traffic lights."] {
		Structure {
			ActorRef controller [2]: PedestrianTrafficLightController
			ActorRef headquarters1: TrafficLightHeadquarters
			ActorRef tlInterface [2]: TrafficLightInterface
			Binding headquarters1.controllers and controller.fct
			Binding controller.tlInterface and tlInterface.fct
		}
		Behavior { }
	}

	ActorClass HierarchicalReplication ["HierarchicalReplication structural hierarchy to combine several actors and replicate them 'en bloc'. It controla 2 traffic lights."] {
		Structure {
			ActorRef controllerWithInfrastructure [2]: TrafficLightControllerWithInfrastructure
			ActorRef headquarters2: TrafficLightHeadquarters
			Binding controllerWithInfrastructure.fct and headquarters2.controllers
		}
		Behavior { }
	}

	ActorClass TrafficLightControllerWithInfrastructure ["The TrafficLightControllerWithInfrastructure encapsules the PedestrianTrafficLightController, the TrafficLightInterface and the SocketClient."] {
		Interface {
			Port fct: PTrafficLightController
		}
		Structure {
			ActorRef controller: PedestrianTrafficLightController
			ActorRef tlInterface: TrafficLightInterface
			Binding controller.tlInterface and tlInterface.fct
			Binding fct and controller.fct
		}
		Behavior { }
	}


	ActorClass TrafficLightControllerTestHarness [
	"Test harness for the TrafficLightController. It has the same ports, but conjugated. It can run test cases for the TrafficLightController by completely simulating its environment."
	] {
		Interface {
			conjugated Port fct: PTrafficLightController
			Port tlInterface: PTrafficLightInterface
		}
		Structure {
			external Port fct
			external Port tlInterface 
			SAP to: PTimer  
			Attribute counter: int32 ["FEATURE: Attribute of an ActorClass"]
		}
		Behavior {
			StateMachine {
				Transition init: initial -> SetStandby
				Transition tr0: SetStandby -> InStandby {
					triggers {
						<doneStandby: fct>
					}
					action {
						"counter=0;"
					}
				}
				Transition tr1: InStandby -> SetStart {
					triggers {
						<setCarYellow: tlInterface guard {
							"++counter==5"
						}>
					}
				}
				Transition tr2: SetStart -> InRunning {
					triggers {
						<doneStart: fct>
					}
				}
				Transition tr3: InRunning -> CarGreen {
					triggers {
						<setCarGreen: tlInterface guard {
							"status==1"
						}>
					}
				}
				Transition tr4: CarGreen -> PressButton {
					triggers {
						<timeout: to>
					}
				}
				Transition tr5: PressButton -> CarGreenAgain {
					triggers {
						<setCarGreen: tlInterface guard {
							"status==1"
						}>
					}
				}
				Transition tr6: CarGreenAgain -> CarYellow {
					triggers {
						<setCarYellow: tlInterface guard {
							"status==1"
						}>
					}
					action {
						"counter=0;"
					}
				}
				Transition tr7: CarYellow -> SetStop {
					triggers {
						<setPedRed: tlInterface guard {
							"++counter==5"
						}>
					}
				}
				Transition tr8: SetStop -> Done {
					triggers {
						<doneStop: fct>
					}
				}
				State SetStandby {
					entry {
						"fct.standby();"
					}
				}
				State InStandby
				State SetStart {
					entry {
						"fct.start();"
					}
				}
				State InRunning
				State CarGreen {
					entry {
						"to.startTimeout(1*10);"
					}
				}
				State PressButton {
					entry {
						"tlInterface.pressedRequestButton();"
					}
				}
				State CarGreenAgain {
					entry {
						"fct.standby();"
					}
				}
				State CarYellow
				State SetStop {
					entry {
						"fct.stop();"
					}
				}
				State Done
			}
		}
	}

	ActorClass PedestrianTrafficLightController [
	"Control of a traffic light at a pedestrian crossing with one car traffic light and one pedestrian traffic light." ]
	{
		Interface {
			Port fct: PTrafficLightController
			conjugated Port tlInterface: PTrafficLightInterface
		}
		Structure {
			external Port fct
			external Port tlInterface
			SAP to: PTimer
			Attribute timeBase: int32
		}
		Behavior {
			StateMachine {
				Transition init: initial -> Stopped {
					action {
						"timeBase = 10;"
					}
				}
				Transition tr0: Stopped -> tp0 of Standby {
					triggers {
						<standby: fct>
					}
				}
				Transition tr1: Standby -> tpStart of Running {
					triggers {
						<start: fct>
					}
				}
				Transition tr2: Running -> AllRedBeforeStandby {
					triggers {
						<standby: fct>
					}
				}
				Transition tr3: tpStandby of Running -> AllRedBeforeStandby
				Transition tr4: AllRedBeforeStandby -> tp0 of Standby {
					triggers {
						<timeout: to>
					}
				}
				Transition tr5: Standby -> Stopped {
					triggers {
						<stop: fct>
					}
				}
				State Stopped {
					entry {
						"tlInterface.setCarRed(0);"
						"tlInterface.setCarYellow(0);"
						"tlInterface.setCarGreen(0);"
						"tlInterface.setPedRed(0);"
						"tlInterface.setPedGreen(0);"
						"fct.doneStop();"
					}
				}
				State Standby {
					entry {
						"fct.doneStandby();"
					}
					subgraph {
						Transition tr0: my tp0 -> On
						Transition tr1: On -> Off {
							triggers {
								<timeout: to>
							}
						}
						Transition tr2: Off -> On {
							triggers {
								<timeout: to>
							}
						}
						EntryPoint tp0
						State On {
							entry {
								"// turn two lights on"
								"tlInterface.setCarYellow(1);"
								"tlInterface.setPedRed(1);"
								""
								"// start timeout (fire once) for blinking"
								"// startTimer would start a cyclic timer"
								"to.startTimeout(5*timeBase);"
							}
							exit {
								"// TIP: turn off lights here in the exit code of state On instead of the entry code of state Off "
								"// to make sure they are turned off if the superstate Standby is left by a group transition"
								"tlInterface.setCarYellow(0);"
								"tlInterface.setPedRed(0);"
								""
								"// TIP: kill timer here to make sure it is killed if the state is left by a group transition or any other transition than a timeout"
								"// ALTERNATIVE: kill() could also be placed in the exit code of the superstate StandbyBlinking and so replacing the two calls in On:exit and Off:exit"
								"to.kill();"
							}
						}
						State Off {
							entry {
								"to.startTimeout(5*timeBase);"
							}
							exit {
								"to.kill();"
							}
						}
					}
				}
				State Running {
					entry {
						"fct.doneStart();"
					}
					exit {
						"to.kill();"
					}
					subgraph {
						Transition tr0: my tpStart -> AllRed
						Transition tr1: AllRed -> CarGreen {
							triggers {
								<timeout: to>
							}
						}
						Transition tr2: CarGreen -> CarYellow {
							triggers {
								<pressedRequestButton: tlInterface>
							}
						}
						Transition tr3: CarYellow -> CarRed {
							triggers {
								<timeout: to>
							}
						}
						Transition tr4: CarRed -> PedGreen {
							triggers {
								<timeout: to>
							}
						}
						Transition tr5: PedGreen -> AllRed {
							triggers {
								<timeout: to>
							}
						}
						Transition tr6: CarGreen -> CarYellowBeforeStandby {
							triggers {
								<standby: fct>
							}
						}
						Transition tr7: CarYellowBeforeStandby -> my tpStandby {
							triggers {
								<timeout: to>
							}
						}
						EntryPoint tpStart
						ExitPoint tpStandby
						State AllRed {
							entry {
								"tlInterface.setCarRed(1);"
								"tlInterface.setPedRed(1);"
								"to.startTimeout(20*timeBase);"
							}
						}
						State CarYellow {
							entry {
								"tlInterface.setCarGreen(0);"
								"tlInterface.setCarYellow(1);"
								"to.startTimeout(10*timeBase);"
							}
						}
						State CarGreen {
							entry {
								"tlInterface.setCarRed(0);"
								"tlInterface.setCarGreen(1);"
							}
						}
						State CarRed {
							entry {
								"tlInterface.setCarYellow(0);"
								"tlInterface.setCarRed(1);"
								"to.startTimeout(10*timeBase);"
							}
						}
						State PedGreen {
							entry {
								"tlInterface.setPedGreen(1);"
								"to.startTimeout(20*timeBase);"
							}
						}
						State CarYellowBeforeStandby {
							entry {
								"tlInterface.setCarGreen(0);"
								"tlInterface.setCarYellow(1);"
								"to.startTimeout(10*timeBase);"
							}
						}
					}
				}
				State AllRedBeforeStandby {
					entry {
						"tlInterface.setCarRed(1);"
						"tlInterface.setPedRed(1);"
						"to.startTimeout(30*timeBase);"
					}
				}
			}
		}
	}

	ActorClass TrafficLightInterface {
		Interface {
			Port fct: PTrafficLightInterface
			conjugated Port tcpControl: PTcpControl
			conjugated Port tcpPayload: PTcpPayload
		}
		Structure {
			external Port fct
			external Port tcpControl
			external Port tcpPayload
		}
		Behavior {
			StateMachine {
				Transition init: initial -> Connecting
				Transition tr0: Connected -> Connected {
					triggers {
						<setCarRed: fct>
					}
				}
				Transition tr1: Connecting -> Connected {
					triggers {
						<established: tcpControl>
					}
				}
				State Connecting
				State Connected
			}
		}
	}

	ActorClass TrafficLightInterfaceStub {
		Interface {
			Port fct: PTrafficLightInterface
		}
		Structure {
			external Port fct
			SAP to: PTimer
		}
		Behavior {
			StateMachine {
				Transition init: initial -> WaitingABit
				Transition tr0: WaitingABit -> PressButton {
					triggers {
						<timeout: to>
					}
				}
				State WaitingABit {
					entry {
						"to.startTimeout(80*10);"
					}
				}
				State PressButton {
					entry {
						"fct.pressedRequestButton();"
						"fct.releasedRequestButton();"
					}
				}
			}
		}
	}

	ActorClass TrafficLightHeadquarters {
		Interface {
			conjugated Port controllers [2]: PTrafficLightController
		}
		Structure {
			external Port controllers
			SAP to: PTimer
		}
		Behavior {
			StateMachine {
				Transition init: initial -> Standby
				Transition tr0: Standby -> Running {
					triggers {
						<timeout: to>
					}
				}
				Transition tr1: Running -> Stopped {
					triggers {
						<timeout: to>
					}
				}
				State Standby {
					entry {
						"controllers.standby();"
						"to.startTimeout(20*10);"
					}
				}
				State Running {
					entry {
						"controllers.start();"
						"to.startTimeout(200*10);"
					}
				}
				State Stopped {
					entry {
						"controllers.stop();"
					}
				}
			}
		}
	}

	ProtocolClass PTrafficLightController {
		incoming {
			Message standby()
			Message start()
			Message stop()
		}
		outgoing {
			Message doneStandby()
			Message doneStart()
			Message doneStop()
		}
	}

	ProtocolClass PTrafficLightInterface {
		incoming {
			Message setCarRed(status: boolean)
			Message setCarYellow(status: boolean)
			Message setCarGreen(status: boolean)
			Message setPedRed(status: boolean)
			Message setPedGreen(status: boolean)
		}
		outgoing {
			Message pressedRequestButton()
		}
	}

}