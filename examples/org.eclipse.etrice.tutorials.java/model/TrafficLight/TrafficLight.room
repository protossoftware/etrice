/*******************************************************************************
 * Copyright (c) 2012 protos software gmbh (http://www.protos.de).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * CONTRIBUTORS:
 * 		Thomas Schuetz (initial contribution)
 * 
 *******************************************************************************/


RoomModel TrafficLight_Model {

	import room.basic.types.* from "../../../org.eclipse.etrice.modellib.java/model/Types.room"

	import room.basic.service.timing.* from "../../../org.eclipse.etrice.modellib.java/model/TimingService.room"

	import room.basic.service.tcp.* from "../../../org.eclipse.etrice.modellib.java/model/TcpService.room"

	LogicalSystem LSTraffic {
		SubSystemRef mainSS: SSTraffic
	}

	SubSystemClass SSTraffic [
	"Subsystem of Trafficlight Example Application. The Subsystem contains all Actors of the application." ] {
		ActorRef application: TrafficlightExampleApplication [ "reference to application" ]
		ActorRef TimingService: ATimingService [ "reference to timing service" ]
		LayerConnection ref application satisfied_by TimingService.timer
		LogicalThread default_thread
	}

	ActorClass TrafficlightExampleApplication [ "Toplevel Actor of the Trafficlight Example Application." ] {
		Structure {
			ActorRef pedestrianLight: PedestrianLight
		}
		Behavior { }
	}

	ActorClass PedestrianLight {
		Structure {
			conjugated Port tcpControl: PTcpControl
			conjugated Port tcpPayload: PTcpPayload
			ActorRef socketClient: ATcpClient
			SAP timeout: PTimer
			Binding tcpControl and socketClient.ControlPort
			Binding tcpPayload and socketClient.PayloadPort
			Attribute ipConfig: DTcpControl [ "configuration of the IP-port for the communication with the Traffic Light GUI" ]
		}
		Behavior {
			Operation sendString(text: string)
			[ "convenience function for sending a string over the socket" ]
			{
				"tcpPayload.send(new DTcpPayload(1, text.length(), text.getBytes()));"
			}
			Operation setLights(car: Light, ped: Light)
			[ "convenience function for sending a command over the socket" ]
			{
				"sendString(\"carLights=\"+getCmd(car)+\"\\n\");"
				"sendString(\"pedLights=\"+getCmd(ped)+\"\\n\");"
			}
			Operation getCmd(light: Light): string
			[ "convenience function for getting a command string" ]
			{
				"switch(light) {"
				"	case Light.RED: return \"red\";"
				"	case Light.GREEN: return \"green\";"
				"	case Light.YELLOW: return \"yellow\";"
				"	default: return \"\";"
				"}"
			}
			StateMachine {
				Transition init: initial -> OpenSocket {
					action {
						"tcpControl.open(ipConfig);"
					}
				}
				Transition tr0: OpenSocket -> Operational {
					triggers {
						<established: tcpControl>
					}
				}
				State OpenSocket
				State Operational {
					subgraph {
						Transition init: initial -> AllRed { }
						Transition tr0: AllRed -> CarGreen {
							triggers {
								<timeout: timeout>
							}
						}
						Transition tr1: CarGreen -> CarYellow {
							triggers {
								<receive: tcpPayload>
							}
						}
						Transition tr2: CarYellow -> CarRed {
							triggers {
								<timeout: timeout>
							}
						}
						Transition tr3: CarRed -> PedGreen {
							triggers {
								<timeout: timeout>
							}
						}
						Transition tr4: PedGreen -> AllRed {
							triggers {
								<timeout: timeout>
							}
						}
						State AllRed {
							entry {
								"setLights(Light.RED, Light.RED);"
								"timeout.startTimeout(1000);"
							}
						}
						State CarGreen {
							entry {
								"setLights(Light.GREEN, Light.RED);"
							}
						}
						State CarYellow {
							entry {
								"setLights(Light.YELLOW, Light.RED);"
								"timeout.startTimeout(1000);"
							}
						}
						State CarRed {
							entry {
								"setLights(Light.RED, Light.RED);"
								"timeout.startTimeout(1000);"
							}
						}
						State PedGreen {
							entry {
								"setLights(Light.RED, Light.GREEN);"
								"timeout.startTimeout(3000);"
							}
						}
					}
				}
			}
		}
	}
	
	Enumeration Light {
		RED,
		GREEN,
		YELLOW
	}

	ProtocolClass PTrafficLight {
		incoming {
			Message greenForCar() [ "trigger green for car" ]
			Message greenForPed() [ "trigger green for pedestrians" ]
		}
		outgoing {
			Message greenForCarDone() [ "positive response for greenForCar - is sent when switch is over" ]
			Message greenForPedDone() [ "positive response for greenForPed - is sent when switch is over" ]
		}
	}

}
