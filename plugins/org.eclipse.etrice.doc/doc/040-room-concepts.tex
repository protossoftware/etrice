\chapter{ROOM Concepts}
\label{sec:room_concepts}

This chapter gives an overview over the ROOM language elements and their textual and graphical notation.
The formal ROOM grammar based on Xtext (EBNF) you can find in the \eTrice{} repository:
\url{http://git.eclipse.org/c/etrice/org.eclipse.etrice.git/plain/plugins/org.eclipse.etrice.core.room/src/org/eclipse/etrice/core/Room.xtext}

\section{Actors}

\subsection{Description}
 
The actor is the basic structural building block for building systems with ROOM. An actor can be refined 
hierarchically and thus can be of arbitrarily large scope. Ports define the interface of an actor.
An actor can also have a behavior usually defined by a finite state machine.

\subsection{Motivation}

\begin{itemize}
\item Actors enable the construction of hierarchical structures by composition and layering
\item Actors have their own logical thread of execution
\item Actors can be freely deployed
\item Actors define potentially re-usable blocks
\end{itemize}

\subsection{Notation}

\begin{table}
\caption{Actor Class Notation}
\begin{tabular}{|l|l|l|}
\hline
 \textbf{Element} & \textbf{Graphical Notation} & \textbf{Textual Notation} \\ \hline
  ActorClass & \includegraphics[scale=0.7]{images/040-ActorClassNotation.png} & 
\includegraphics[scale=0.7]{images/040-ActorClassTextualNotation.png} \\ \hline
  ActorRef & \includegraphics[scale=0.7]{images/040-ActorReferenceNotation.png} & 
\includegraphics[scale=0.7]{images/040-ActorReferenceTextualNotation.png} \\ \hline
\end{tabular}
\end{table}


\subsection{Details}

\subsubsection{Actor Classes, Actor References, Ports and Bindings}

An \room{ActorClass} defines the type (or blueprint) of an actor. Hierarchies are built by \room{ActorClass}es
that contain \room{ActorRef}erences which have another \room{ActorClass} as type. The interface of an 
\room{ActorClass} is always defined by \room{Port}s. The \room{ActorClass} can also contain
\room{Attribute}s, \room{Operation}s
and a finite \room{StateMachine}. 

External \room{Port}s define the external interface of an actor and are defined in the \room{Interface} 
section of the \room{ActorClass}.

Internal \room{Port}s define the internal interface of an actor and are defined in the \room{Structure} 
section of the \room{ActorClass}.

\room{Binding}s connect \room{Port}s inside an \room{ActorClass}.

Let us have a look at example \ref{tab:actor_class_example}:

\begin{table}
\caption{Actor Class Example}
\label{tab:actor_class_example}
\begin{tabular}{|l|l|l|}
\hline
 \textbf{Graphical Notation} & \textbf{Textual Notation} \\ \hline
 \includegraphics[scale=0.7]{images/040-ActorClass.png} & 
\includegraphics[scale=0.7]{images/040-ActorClassExampleTextualNotation.png} \\ \hline
 \end{tabular}
 \end{table}

\begin{itemize}
\item \textit{ActorClass1} contains two \room{ActorRef}erences (of ActorClass2 and ActorClass3)
\item \textit{port1} is an \textit{external end port}. Since it connects external actors with the behavior 
of the \room{ActorClass}, it is defined in the \room{Interface} section and the \room{Structure} section of 
the \room{ActorClass}.
\item \textit{port2} and \textit{port3} are \textit{internal end ports} and can only be connected to the 
ports of contained \room{ActorRef}erences. Internal end ports connect the behavior of an \room{ActorClass} with its 
contained \room{ActorRef}erences.
\item \textit{port4} is a relay port and connects external Actors to contained \room{ActorRef}erences. This port 
can not be accessed by the behavior of the \room{ActorClass}.
\item \textit{port5} through \textit{port9} are ports of contained actor references. \textit{port8} and 
\textit{port9} can communicate without interference with the containing actor class.
\item \room{Binding}s can connect ports of the actor class and its contained actor references. 
\end{itemize}

\subsubsection{Attributes}

\room{Attribute}s are part of the \room{Structure} of an actor class.
They can be of a \room{PrimitiveType} or a \room{DataClass}.

Example:

\includegraphics{images/040-ActorClassAttributes.png}

\subsubsection{Operations}

\room{Operation}s are part of the \room{Behavior} of an actor class.  Arguments and return values can be of a 
\room{PrimitiveType} or a \room{DataClass}. Data classes can be passed by value (implicit) or by reference (\room{ref}).

Example:

\includegraphics{images/040-ActorClassOperations.png}

\section{Protocols}

\subsection{Description}

A \room{ProtocolClass} defines a set of incoming and outgoing \room{Message}s that can be exchanged between two ports.
The exact semantics of a message is defined by the execution model.

\subsection{Motivation}

\begin{itemize}
\item Protocol classes provide a reusable interface specification for ports
\item Protocol classes can optionally specify valid message exchange sequences
\end{itemize}

\subsection{Notation}

Protocol classes have only textual notation. 
The example defines a protocol class with 2 incoming and two outgoing messages. Messages can have data 
attached. The data can be of a primitive type (e.g. int32, float64, ...) or a data class.

\includegraphics{images/040-ProtocolClassTextualNotation.png}

\section{Ports}

\subsection{Description}

\room{Port}s are the only interfaces of actors. A port has always a protocol assigned. 
Service Access Points (SAP) and Service Provision Points (SPP) are specialized ports that are used to 
define layering.

\subsection{Motivation}

\begin{itemize}
\item Ports decouple interface definition (protocols) from interface usage
\item Ports decouple the logical interface from the transport 
\end{itemize}

\subsection{Notation}

\subsubsection{Class Ports}

These symbols can only appear on the border of an actor class symbol.

Ports that define an external interface of the actor class, are defined in the \room{Interface}. Ports 
that define an internal interface are defined in the \room{Structure} (e.g. internal ports).

\begin{itemize}
\item \textit{External end ports} are defined in the Interface and the Structure
\item \textit{Internal end ports} are only defined in the Structure
\item \textit{Relay ports} are only defined in the Interface
\item \textit{End ports} are always connected to the internal behavior of the ActorClass
\item \textit{Replicated ports} can be defined with a fixed replication factor, e.g.\\
\texttt{\room{Port} port18 [5]: ProtocolClass1}\\
or a variable replication factor, e.g.\\
\texttt{\room{Port} port18[*]: ProtocolClass1}
\end{itemize}

The table \ref{tab:class_port_notation} shows all kinds of class ports with textual and graphical notation.

\begin{table}
\caption{Class Port Notation}
\label{tab:class_port_notation}
\begin{longtable}{|b{2.5cm}|c|b{5.5cm}|}
\hline
 \textbf{Element} & \textbf{Graphical Notation} & \textbf{Textual Notation} \\ \hline
 \raggedright Class End Port & \includegraphics[scale=0.7]{images/040-ClassEndPort.png} & 
\begin{tabular}{c} \textit{External Class End Port:} \\ 
\includegraphics[scale=0.7]{images/040-ClassEndPortTextual.png} \\ \textit{Internal Class End Port:} \\ 
\includegraphics[scale=0.7]{images/040-ClassEndPortInternalTextual.png} \\ \end{tabular} \\ \hline
 \raggedright Conjugated Class End Port & 
\includegraphics[scale=0.7]{images/040-ConjugatedClassEndPort.png} & \begin{tabular}{b{5.5cm}} 
\textit{External Conjugated Class End Port:} \\ 
\includegraphics[scale=0.7]{images/040-ConjugatedClassEndPortTextual.png}\\ \textit{Internal Conjugated 
Class End Port:} \\ \includegraphics[scale=0.7]{images/040-ConjugatedClassEndPortInternalTextual.png} \\ 
\end{tabular} \\ \hline
 \raggedright Class Relay Port & \includegraphics[scale=0.7]{images/040-ClassRelayPort.png} & 
\includegraphics[scale=0.7]{images/040-ClassRelayPortTextual.png} \\ \hline
 \raggedright Conjugated Class Relay Port & 
\includegraphics[scale=0.7]{images/040-ConjugatedClassRelayPort.png} & 
\includegraphics[scale=0.7]{images/040-ConjugatedClassRelayPortTextual.png} \\ \hline
 \raggedright Replicated Class End Port & 
\includegraphics[scale=0.7]{images/040-ReplicatedClassEndPort.png} & \begin{tabular}{b{5.5cm}} 
\textit{External Replicated Class End Port:} \\ 
\includegraphics[scale=0.7]{images/040-ReplicatedClassEndPortTextual.png} \\ \textit{Internal Replicated 
Class End Port:} \\ \includegraphics[scale=0.7]{images/040-ReplicatedClassEndPortInternalTextual.png} \\ 
\end{tabular} \\ \hline
 \raggedright Conjugated Replicated Class End Port & 
\includegraphics[scale=0.7]{images/040-ConjugatedReplicatedClassEndPort.png} & \begin{tabular}{b{5.5cm}} 
\textit{External Conjugated Replicated Class End Port:} \\ 
\includegraphics[scale=0.7]{images/040-ConjugatedReplicatedClassEndPortTextual.png} \\ \textit{Internal 
Conjugated Replicated Class End Port:} \\ 
\includegraphics[scale=0.7]{images/040-ConjugatedReplicatedClassEndPortInternalTextual.png} \\ 
\end{tabular} \\ \hline
 \raggedright Replicated Class Relay Port & 
\includegraphics[scale=0.7]{images/040-ReplicatedClassRelayPort.png} & 
\includegraphics[scale=0.7]{images/040-ReplicatedClassRelayPortTextual.png} \\ \hline
 \raggedright Conjugated Replicated Class Relay Port & 
\includegraphics[scale=0.7]{images/040-ConjugatedReplicatedClassRelayPort.png} & 
\includegraphics[scale=0.7]{images/040-ConjugatedReplicatedClassRelayPortTextual.png} \\ \hline
\end{longtable}
\end{table}

\subsubsection{Reference Ports}

These symbols can only appear on the border of an actor class. Since the type of port is defined 
in the actor class, no textual notation for the Reference Ports exists.

The table \ref{tab:reference_port_notation} shows all kinds of reference ports with textual and graphical notation.

\begin{table}
\caption{Reference Port Notation}
\label{tab:reference_port_notation}
\begin{tabular}{|c|c|c|}
\hline
 \textbf{Element} & \textbf{Graphical Notation} & \textbf{Textual Notation} \\ \hline
 Reference Port & \includegraphics{images/040-ReferencePort.png} & \textit{implicit} \\ \hline
 Conjugated Reference Port & \includegraphics{images/040-ConjugatedReferencePort.png} & \textit{implicit} 
\\ \hline
 Replicated Reference Port & \includegraphics{images/040-ReplicatedReferencePort.png} & \textit{implicit} 
\\ \hline
 Conjugated Replicated \\ Reference Port & 
\includegraphics{images/040-ConjugatedReplicatedReferencePort.png} & \textit{implicit} \\ \hline
\end{tabular}
\end{table}

\section{DataClass}

\subsection{Description}

The \room{DataClass} enables the modeling of hierarchical complex data types and operations on them.
The data class is the equivalent to a class in languages like Java or C++, but has less features. The content of a 
data class can always be sent via message between actors (defined as message data in a \room{ProtocolClass}).

\subsection{Notation}
  
Example: DataClass using PrimitiveTypes

\includegraphics{images/040-DataClass1.png}

Example: DataClass using other DataClasses:

\includegraphics{images/040-DataClass2.png}

\section{Layering}

\subsection{Description}

In addition to the actor containment hierarchies, layering provides another method to hierarchically 
structure a software system. Layering and actor hierarchies with port to port connections can be mixed on 
every level of granularity.
\begin{enumerate}
\item an ActorClass can define a Service Provision Point (SPP) to publish a specific service, defined by a 
ProtocolClass
\item an ActorClass can define a Service Access Point (SAP) if it needs a service, defined by a 
ProtocolClass
\item for a given Actor hierarchy, a LayerConnection defines which SAP will be satisfied by (connected to) 
which SPP
\end{enumerate}

\subsection{Notation}

\begin{table}
\begin{tabular}{|m{3cm}|c|c|}
\hline
 \textbf{Description} & \textbf{Graphical Notation} & \textbf{Textual Notation} \\ \hline
 \begin{flushleft}The Layer Connections in this model define which services are provided by the 
\textit{ServiceLayer} (\textit{digitalIO} and \textit{timer})\end{flushleft} & 
\includegraphics[scale=0.5]{images/040-LayeringModel.png} & 
\includegraphics[scale=0.5]{images/040-LayeringModelTextual.png}  \\ \hline
 \begin{flushleft}The implementation of the services (SPPs) can be delegated to sub actors. In this case 
the actor \textit{ServiceLayer} relays (delegates) the implementation services \textit{digitalIO} and 
\textit{timer} to sub actors\end{flushleft} & 
\includegraphics[scale=0.5]{images/040-LayeringServiceLayer.png} & 
\includegraphics[scale=0.5]{images/040-LayeringServiceLayerTextual.png} \\ \hline
 \begin{flushleft}Every Actor inside the \textit{ApplicationLayer} that contains an SAP with the same 
Protocol as \textit{timer} or \textit{digitalIO} will be connected to the specified SPP\end{flushleft} & 
\includegraphics[scale=0.5]{images/040-LayeringApplicationLayer.png} & 
\includegraphics[scale=0.5]{images/040-LayeringApplicationLayerTextual.png} \\ \hline
\end{tabular}
\end{table}

\section{Finite State Machines}

\subsection{Description}

Definition from \href{http://en.wikipedia.org/wiki/Finite-state\_machine}{Wikipedia}:

\begin{quote}
A finite-state machine (FSM) or finite-state automaton (plural: automata), or simply a state machine, is a 
mathematical model used to design computer programs and digital logic circuits. It is conceived as an 
abstract machine that can be in one of a finite number of states. The machine is in only one state at a 
time; the state it is in at any given time is called the current state. It can change from one state to 
another when initiated by a triggering event or condition, this is called a transition. A particular FSM 
is defined by a list of the possible states it can transition to from each state, and the triggering 
condition for each transition.

In ROOM each actor class can implement its behavior using a state machine. Events occurring at the end 
ports of an actor will be forwarded to and processed by the state machine. Events possibly trigger state 
transitions.
\end{quote}

\subsection{Motivation}

For event driven systems a finite state machine is ideal for processing the stream of events. Typically 
during processing new events are produced which are sent to peer actors.

We distinguish flat and hierarchical state machines.

\subsection{Notation}

\subsubsection{Flat Finite State Machine}

The simpler flat finite state machines are composed of the following elements:

\begin{table}
\caption{Title}
\begin{tabular}{|c|c|c|}
\hline
 \textbf{Description} & \textbf{Graphical Notation} & \textbf{Textual Notation} \\ \hline
 State & \includegraphics{images/040-State.jpg} & \includegraphics[scale=0.7]{images/040-StateTextual.jpg} 
\\ \hline
 InitialPoint & \includegraphics{images/040-InitialPoint.jpg} & \textit{implicit} \\ \hline
 TransitionPoint & \includegraphics{images/040-TransitionPoint.jpg} & 
\includegraphics[scale=0.7]{images/040-TransitionPointTextual.jpg} \\ \hline
 ChoicePoint & \includegraphics{images/040-ChoicePoint.jpg} & 
\includegraphics[scale=0.7]{images/040-ChoicePointTextual.jpg} \\ \hline
 Initial Transition & \includegraphics[scale=0.7]{images/040-InitialTransition.jpg} & 
\includegraphics[scale=0.7]{images/040-InitialTransitionTextual.jpg} \\ \hline
 Triggered Transition & \includegraphics[scale=0.7]{images/040-TriggeredTransition.jpg} & 
\includegraphics[scale=0.5]{images/040-TriggeredTransitionTextual.jpg} \\ \hline
\end{tabular}
\end{table}
% <table title="Title" frame="box" border="2" cellpadding="3" cellspacing="0">
	% <tr>
		% <td align="center">\emph{Description}</td>
		% <td align="center">\emph{Graphical Notation}</td>
		% <td align="center">\emph{Textual Notation}</td>
	% </tr>
	% <tr>
		% <td>State</td>
		% <td>!images/040-State.jpg!</td>
		% <td>!images/040-StateTextual.jpg!</td>
	% </tr>
	% <tr>
		% <td>InitialPoint</td>
		% <td>!images/040-InitialPoint.jpg!</td>
		% <td>_implicit_</td>
	% </tr>
	% <tr>
		% <td>TransitionPoint</td>
		% <td>!images/040-TransitionPoint.jpg!</td>
		% <td>!images/040-TransitionPointTextual.jpg!</td>
	% </tr>
	% <tr>
		% <td>ChoicePoint</td>
		% <td>!images/040-ChoicePoint.jpg!</td>
		% <td>!images/040-ChoicePointTextual.jpg!</td>
	% </tr>
	% <tr>
		% <td>Initial Transition</td>
		% <td>!images/040-InitialTransition.jpg!</td>
		% <td>!images/040-InitialTransitionTextual.jpg!</td>
	% </tr>
	% <tr>
		% <td>Triggered Transition</td>
		% <td>!images/040-TriggeredTransition.jpg!</td>
		% <td>!images/040-TriggeredTransitionTextual.jpg!</td>
	% </tr>
% </table>


\subsubsection{Hierarchical Finite State Machine}

The hierarchical finite state machine adds the notion of a sub state machine nested in a state.
A few modeling elements are added to the set listed above:

\begin{table}
\caption{Title}
\begin{tabular}{|b{3cm}|c|c|}
\hline
 \textbf{Description} & \textbf{Graphical Notation} & \textbf{Textual Notation} \\ \hline
 State with sub state machine & \specialcell{Parent State \\ 
\includegraphics[scale=0.7]{images/040-StateWithSubFSM.jpg}} & \specialcell{Sub state machine \\ 
\includegraphics[scale=0.5]{images/040-StateWithSubFSMTextual.jpg}} \\ \hline
 Entry Point & \specialcell{In sub state machine \\ 
\includegraphics[scale=0.7]{images/040-EntryPoint.jpg}} & \specialcell{ \\ 
\includegraphics{images/040-EntryPointTextual.jpg}} \\ \hline
 Exit Point & & \includegraphics{images/040-ExitPointTextual.jpg} \\ \hline
\end{tabular}
\end{table}

% <table title="Title" frame="box" border="2" cellpadding="3" cellspacing="0">
	% <tr>
		% <td align="center">\emph{Description}</td>
		% <td align="center">\emph{Graphical Notation}</td>
		% <td align="center">\emph{Textual Notation}</td>
	% </tr>
	% <tr>
		% <td>State with sub state machine</td>
		% <td>Parent State
		% !images/040-StateWithSubFSM.jpg!
		% Sub state machine
		% !images/040-SubFSM.jpg!</td>
		% <td>!images/040-StateWithSubFSMTextual.jpg!</td>
	% </tr>
	% <tr>
		% <td>Entry Point</td>
		% <td>In sub state machine
		% !images/040-EntryPoint.jpg!
		% On parent state
		% !images/040-EntryPointRef.jpg!</td>
		% <td>!images/040-EntryPointTextual.jpg!</td>
	% </tr>
	% <tr>
		% <td>Exit Point</td>
		% <td>In sub state machine
		% !images/040-ExitPoint.jpg!
		% On parent state
		% !images/040-ExitPointRef.jpg!</td>
		% <td>!images/040-ExitPointTextual.jpg!</td>
	% </tr>
% </table>


\subsection{Examples}

\subsubsection{Example of a flat finite state machine:}

% !images/040-FlatFSM.jpg!
\includegraphics[scale=0.7]{images/040-FlatFSM.jpg}

\subsubsection{Example of a hierarchical finite state machine:}

Top level

% !images/040-HierarchicalFSMTop.jpg!
\includegraphics[scale=0.7]{images/040-HierarchicalFSMTop.jpg}

Sub state machine of Initializing

% !images/040-HierarchicalFSMInitializing.jpg!
\includegraphics[scale=0.7]{images/040-HierarchicalFSMInitializing.jpg}

Sub state machine of Running

% !images/040-HierarchicalFSMRunning.jpg!
\includegraphics[scale=0.7]{images/040-HierarchicalFSMRunning.jpg}