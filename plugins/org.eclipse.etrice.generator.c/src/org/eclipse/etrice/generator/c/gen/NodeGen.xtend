/*******************************************************************************
 * Copyright (c) 2011 protos software gmbh (http://www.protos.de).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * CONTRIBUTORS:
 * 		Henrik Rentz-Reichert (initial contribution)
 * 		Thomas Schuetz (changed for C code generator)
 * 
 *******************************************************************************/

package org.eclipse.etrice.generator.c.gen

import com.google.inject.Inject
import com.google.inject.Singleton
import java.util.ArrayList
import java.util.HashMap
import org.eclipse.etrice.core.genmodel.base.ILogger
import org.eclipse.etrice.core.genmodel.etricegen.ActorInstance
import org.eclipse.etrice.core.genmodel.etricegen.InterfaceItemInstance
import org.eclipse.etrice.core.genmodel.etricegen.PortInstance
import org.eclipse.etrice.core.genmodel.etricegen.Root
import org.eclipse.etrice.core.genmodel.etricegen.SubSystemInstance
import org.eclipse.etrice.core.room.ActorCommunicationType
import org.eclipse.etrice.core.room.CommunicationType
import org.eclipse.etrice.core.room.ProtocolClass
import org.eclipse.etrice.core.etmap.util.ETMapUtil
import org.eclipse.etrice.generator.generic.ILanguageExtension
import org.eclipse.etrice.generator.generic.ProcedureHelpers
import org.eclipse.etrice.generator.generic.RoomExtensions
import org.eclipse.xtext.generator.JavaIoFileSystemAccess

import static extension org.eclipse.etrice.core.room.util.RoomHelpers.*

@Singleton
class NodeGen {
	
	@Inject extension JavaIoFileSystemAccess fileAccess
	@Inject extension CExtensions
	@Inject extension RoomExtensions
	@Inject extension ProcedureHelpers helpers
	@Inject Initialization attrInitGenAddon
	@Inject ILanguageExtension languageExt
	@Inject ILogger logger
	
	def doGenerate(Root root) {
		for (nr : ETMapUtil::getNodeRefs()) {
			for (instpath : ETMapUtil::getSubSystemInstancePaths(nr)) {
				val ssi = root.getInstance(instpath) as SubSystemInstance
				var filepath = ssi.subSystemClass.generationTargetPath+ssi.subSystemClass.getPath
				var file = nr.getCHeaderFileName(ssi)
				logger.logInfo("generating Node declaration: '"+file+"' in '"+filepath+"'")
				fileAccess.setOutputPath(filepath)
				fileAccess.generateFile(file, root.generateHeaderFile(ssi))
				
				file = nr.getCSourceFileName(ssi)
				logger.logInfo("generating Node implementation: '"+file+"' in '"+filepath+"'")
				fileAccess.setOutputPath(filepath)
				fileAccess.generateFile(file, root.generateSourceFile(ssi))
				
				file = nr.getInstSourceFileName(ssi)
				logger.logInfo("generating Node instance file: '"+file+"' in '"+filepath+"'")
				fileAccess.setOutputPath(filepath)
				fileAccess.generateFile(file, root.generateInstanceFile(ssi))
	
				file = nr.getDispSourceFileName(ssi)
				logger.logInfo("generating Node dispatcher file: '"+file+"' in '"+filepath+"'")
				fileAccess.setOutputPath(filepath)
				fileAccess.generateFile(file, root.generateDispatcherFile(ssi))
			}
		}
	}

	def private generateHeaderFile(Root root, SubSystemInstance ssi) {
	val nr = ETMapUtil::getNodeRef(ssi)
	val ssc = ssi.subSystemClass
	val clsname = nr.name+"_"+ssi.name
	'''
		/**
		 * @author generated by eTrice
		 *
		 * Header File of Node «nr.name» with SubSystem «ssi.name»
		 * 
		 */
		
		«generateIncludeGuardBegin(clsname)»

«««		TODOCGENPHYS: user code?
		«helpers.userCode(ssc.userCode1)»
		
		
		/* lifecycle functions
		 * init -> start -> run (loop) -> stop -> destroy
		 */
		
		void «clsname»_init(void);		/* lifecycle init  	 */
		void «clsname»_start(void);	/* lifecycle start 	 */
		
		void «clsname»_run(void);		/* lifecycle run 	 */
		
		void «clsname»_stop(void); 	/* lifecycle stop	 */
		void «clsname»_destroy(void); 	/* lifecycle destroy */
		
		void «clsname»_shutdown(void);  /* shutdown the dispatcher loop */
		
«««		TODOCGENPHYS: user code?
		«helpers.userCode(ssc.userCode2)»
		
		«generateIncludeGuardEnd(clsname)»
		
		
	'''
	}
	
	def private generateSourceFile(Root root, SubSystemInstance ssi) {
	val nr = ETMapUtil::getNodeRef(ssi)
	val ssc = ssi.subSystemClass
	val clsname = nr.name+"_"+ssi.name
	'''
		/**
		 * @author generated by eTrice
		 *
		 * Source File of Node «nr.name» with SubSystem «ssi.name»
		 * 
		 */
		
		#include "«nr.getCHeaderFileName(ssi)»"

		/* include instances for all classes */
		#include "«nr.getInstSourceFileName(ssi)»"
		#include "«nr.getDispSourceFileName(ssi)»"

		#include "debugging/etLogger.h"
		#include "debugging/etMSCLogger.h"
		
		#include "platform/etTimer.h"
		#include "etRuntimeConfig.h"

«««		TODOCGENPHYS: user code?
		«helpers.userCode(ssc.userCode3)»
		
		/* data for Node «nr.name» with SubSytsem «ssi.name» */
		typedef struct «clsname» {
			char *name;
			volatile int shutdownRequest;
		} «clsname»;
		
		static «clsname» «clsname»Inst = {"«clsname»", 0};
		
		void «clsname»_initActorInstances(void);
		void «clsname»_constructActorInstances(void);

		static void «clsname»_initMessageServices(void) {
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "initMessageServices")
			
			/* filling all message service threads with data */
			«FOR thread: nr.type.threads SEPARATOR "\n"»
				msgService_«thread.name».thread.stacksize = «thread.stacksize»;
				msgService_«thread.name».thread.priority = «thread.prio»;
				msgService_«thread.name».thread.threadName = "«thread.name»";
				msgService_«thread.name».thread.threadFunction = (etThreadFunction) etMessageService_execute;
				msgService_«thread.name».thread.threadFunctionData = &msgService_«thread.name»;
				
			«ENDFOR»
			/* initialization of all message services */
			«FOR thread: nr.type.threads»
				etMessageService_init(&msgService_«thread.name», msgBuffer_«thread.name», «thread.msgpoolsize», «thread.msgblocksize», MsgDispatcher_«thread.name»_receiveMessage);
			«ENDFOR»
			
			ET_MSC_LOGGER_SYNC_EXIT
		}

		static void «clsname»_startMessageServices(void) {
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "startMessageServices")
			
			«FOR thread: nr.type.threads»
				etMessageService_start(&msgService_«thread.name»);
			«ENDFOR»
			
			ET_MSC_LOGGER_SYNC_EXIT
		}

		static void «clsname»_stopMessageServices(void) {
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "stopMessageServices")
			
			«FOR thread: nr.type.threads»
				etMessageService_stop(&msgService_«thread.name»);
			«ENDFOR»
			
			ET_MSC_LOGGER_SYNC_EXIT
		}

		static void «clsname»_destroyMessageServices(void) {
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "destroyMessageServices")
			
			«FOR thread: nr.type.threads»
				etMessageService_destroy(&msgService_«thread.name»);
			«ENDFOR»
			
			ET_MSC_LOGGER_SYNC_EXIT
		}
		
		void «clsname»_init(void) {
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "init")
			etLogger_logInfoF("%s_init", «clsname»Inst.name);
			
			/* construct all actors */
			«clsname»_constructActorInstances();
			
			/* initialization of all message services */
			«clsname»_initMessageServices();
			
			/* init all actors */
			«clsname»_initActorInstances();
			
			ET_MSC_LOGGER_SYNC_EXIT
		}
		
		void «clsname»_start(void) {
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "start")
			etLogger_logInfoF("%s_start", «clsname»Inst.name);
			«clsname»_startMessageServices();
			ET_MSC_LOGGER_SYNC_EXIT
		}
		
		void «clsname»_run(void) {
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "run")
			
«««			TODOCGENPHYS: main loop
			etThread_sleep(1000);
			
«««			#ifdef ET_RUNTIME_ENDLESS
«««				while(!(«ssc.name»Inst.shutdownRequest)){
«««					if (etTimer_executeNeeded()){
«««						etMessageService_execute(&msgService_Thread1);
«««						«generateDatadrivenExecutes(root, ssi)»
«««					}
«««				}
«««			#else
«««				uint32 loopCounter = 0;
«««				while(!(«ssc.name»Inst.shutdownRequest)){
«««					if (etTimer_executeNeeded()){
«««						etMessageService_execute(&msgService_Thread1);
«««						«generateDatadrivenExecutes(root, ssi)»
«««						etLogger_logInfo("Execute");
«««						if (loopCounter++ > ET_RUNTIME_MAXLOOP){
«««							break;
«««						}
«««					}
«««				}
«««			#endif
			
			ET_MSC_LOGGER_SYNC_EXIT
		}
		
		void «clsname»_stop(void){
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "stop")
			etLogger_logInfoF("%s_stop", «clsname»Inst.name);
		
			«clsname»_stopMessageServices();
			
			ET_MSC_LOGGER_SYNC_EXIT
		}
		
		void «clsname»_destroy(void){
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "destroy")
			etLogger_logInfoF("%s_destroy", «clsname»Inst.name);
			«FOR ai : ssi.allContainedInstances.reverseView»
				«IF !ai.actorClass.operations.filter(op|op.destructor).empty»
					«languageExt.memberInUse(ai.actorClass.name, languageExt.destructorName(ai.actorClass.name))»(&«ai.path.getPathName()»);
				«ENDIF»
			«ENDFOR»
			
			«clsname»_destroyMessageServices();
			
			ET_MSC_LOGGER_SYNC_EXIT
		}

		void «clsname»_shutdown(void){
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "shutdown")
			etLogger_logInfoF("%s_shutdown", «clsname»Inst.name);
			
			«clsname»Inst.shutdownRequest = 1;
			
			ET_MSC_LOGGER_SYNC_EXIT
		}


		void «clsname»_constructActorInstances(void){
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "constructActorInstances")
			
			«FOR ai : ssi.allContainedInstances»
				«IF !ai.actorClass.operations.filter(op|op.constructor).empty»
					«languageExt.memberInUse(ai.actorClass.name, languageExt.constructorName(ai.actorClass.name))»(&«ai.path.getPathName()»);
				«ENDIF»
			«ENDFOR»
			
			ET_MSC_LOGGER_SYNC_EXIT
		}

		void «clsname»_initActorInstances(void){
			ET_MSC_LOGGER_SYNC_ENTRY("«clsname»", "initActorInstances")
			
			«FOR ai : ssi.allContainedInstances»
				«ai.actorClass.name»_init(&«ai.path.getPathName()»);
			«ENDFOR»
			
			ET_MSC_LOGGER_SYNC_EXIT
		}
		
	'''
	}

	def private generateInstanceFile(Root root, SubSystemInstance ssi) {
	val nr = ETMapUtil::getNodeRef(ssi)
	'''
		/**
		 * @author generated by eTrice
		 *
		 * Instance File of Node «nr.name» with SubSystem «ssi.name»
		 * - instantiation of all actor instances and port instances
		 * - configuration of data and connection of ports
		 */

		#include "messaging/etMessageService.h"
		#include "platform/etMemory.h"

		/* include all used ActorClasses */
		«FOR actorClass : root.getUsedActorClasses()»
			#include "«actorClass.name».h"
		«ENDFOR»

		/* include all used ProtcolClasses */
		«FOR protocolClass : root.getUsedProtocolClasses()»
			#include "«protocolClass.name».h"
		«ENDFOR»
		
		/* instantiation of message services and message buffers */
		«FOR thread: nr.type.threads»
			/* «thread.name» */
			static uint8 msgBuffer_«thread.name»[«thread.msgpoolsize» * «thread.msgblocksize»]; /* msgBuffer_<threadname>[<msgpoolsize> * <msgblocksize>] */ 
			static etMessageService msgService_«thread.name»;
		«ENDFOR»
		
		/* declarations of all ActorClass instances (const and variable structs) */

		/* forward declaration of variable actor structs */
		«FOR ai : ssi.allContainedInstances»
			static «ai.actorClass.name» «ai.path.getPathName()»;
		«ENDFOR»
		
		/* forward declaration of variable port structs */		
		«FOR ai: ssi.allContainedInstances»
			«IF ai.orderedIfItemInstances.empty»
				/*nothing to do */
			«ELSE»
				«FOR pi:ai.orderedIfItemInstances»
					«IF pi.protocol.getPortClass(pi.conjugated)?.attributes?.size > 0»
						static «pi.protocol.getPortClassName(pi.conjugated)»_var «pi.path.pathName»_var«IF pi.replicated»[«pi.peers.size»]«ENDIF»={
							«FOR Integer i:1.. if(pi.peers.size==0)1 else pi.peers.size SEPARATOR ', '»
								«attrInitGenAddon.generateAttributeInit(pi, pi.interfaceItem.portClass.attributes)»
							«ENDFOR»};
					«ENDIF»		
				«ENDFOR»
			«ENDIF» 
		«ENDFOR»
		
		«FOR ai : ssi.allContainedInstances»
			
			/* instance «ai.path.getPathName()» */
			«IF ai.orderedIfItemInstances.empty»
				/* no ports/saps/services - nothing to initialize statically */
			«ELSE»
				«genActorInstanceInitializer(root, ai)»
			«ENDIF»
		«ENDFOR»
		
	'''
	}
	
	def private genActorInstanceInitializer(Root root, ActorInstance ai) {
		var instName = ai.path.pathName
		
		// list of replicated ports
		var replPorts = new ArrayList<InterfaceItemInstance>()
		replPorts.addAll(ai.orderedIfItemInstances.filter(e|e.replicated))
		var haveReplSubPorts = replPorts.findFirst(e|!e.peers.empty)!=null
		
		var simplePorts = ai.orderedIfItemInstances.filter(e|e.simple)
		
		// list of event ports, simple first, then replicated
		var eventPorts = new ArrayList<InterfaceItemInstance>()
		eventPorts.addAll(simplePorts.filter(p|p.protocol.commType==CommunicationType::EVENT_DRIVEN).union(replPorts))

		var dataPorts = simplePorts.filter(p|p.protocol.commType==CommunicationType::DATA_DRIVEN)
		var recvPorts = dataPorts.filter(p|p instanceof PortInstance && !(p as PortInstance).port.conjugated)
		var sendPorts = dataPorts.filter(p|p instanceof PortInstance && (p as PortInstance).port.conjugated)
		
		// compute replicated port offsets		
		var offsets = new HashMap<InterfaceItemInstance, Integer>()
		var offset = 0
		for (p: replPorts) {
			offsets.put(p, offset)
			offset = offset + p.peers.size
		}
		
		var replSubPortsArray = if (haveReplSubPorts) instName+"_repl_sub_ports" else "NULL"
		
	'''
		«IF haveReplSubPorts»
			static const etReplSubPort «replSubPortsArray»[«offset»] = {
				/* Replicated Sub Ports: {varData, msgService, peerAddress, localId, index} */
				«FOR pi : replPorts.filter(e|!e.peers.empty) SEPARATOR ","»
					«genReplSubPortInitializers(root, ai, pi)»
				«ENDFOR»
			};
		«ENDIF»
		«IF !(eventPorts.empty && recvPorts.empty)»
			static const «ai.actorClass.name»_const «instName»_const = {
				/* Ports: {varData, msgService, peerAddress, localId} */
				«FOR pi : eventPorts SEPARATOR ","»
					«IF pi.simple»
						«genPortInitializer(root, ai, pi)»
					«ELSE»
						{«pi.peers.size», «replSubPortsArray»+«offsets.get(pi)»}
					«ENDIF»
				«ENDFOR»
				«IF !eventPorts.empty && !recvPorts.empty»,«ENDIF»
				
				/* data receive ports */
				«FOR pi : recvPorts SEPARATOR ","»
					«genRecvPortInitializer(root, ai, pi)»
				«ENDFOR»
			};
			static «ai.actorClass.name» «instName» = {
				&«instName»_const,
				
				/* data send ports */
				«FOR pi : sendPorts»
					«pi.genSendPortInitializer»,
				«ENDFOR»
				
				/* attributes */
				«attrInitGenAddon.generateAttributeInit(ai, ai.actorClass.allAttributes)»
				
				/* state and history are initialized in init fuction */
			};
		«ENDIF»
	'''}
		
	def private String genPortInitializer(Root root, ActorInstance ai, InterfaceItemInstance pi) {
		val objId = if (pi.peers.empty) 0 else pi.peers.get(0).objId
		val idx = if (pi.peers.empty) 0 else pi.peers.get(0).peers.indexOf(pi)
		val msgSvc = if (pi.peers.empty) "NULL" else "&msgService_"+ETMapUtil::getPhysicalThread(pi.peers.get(0).eContainer as ActorInstance).name
		
		"{"+getInterfaceItemInstanceData(pi)+", " 
		+msgSvc+", "
		+(objId+idx)+", "
		+(root.getExpandedActorClass(ai).getInterfaceItemLocalId(pi.interfaceItem)+1)
		+"} /* Port "+pi.name+" */"
	}
	
	def private genSendPortInitializer(InterfaceItemInstance pi) {
		val pc = (pi as PortInstance).port.protocol as ProtocolClass
		
		'''
			{
				«FOR m : pc.incomingMessages SEPARATOR ","»
					«m.data.refType.type.defaultValue»
				«ENDFOR»
			}
		'''
	}
	
	def private getInterfaceItemInstanceData(InterfaceItemInstance pi){
		if (pi.protocol.getPortClass(pi.conjugated)== null) return "0"
		if (pi.protocol.getPortClass(pi.conjugated).attributes.empty){
			return "0"
		}else{
			return "&"+pi.path.pathName+"_var"
		}
	}
	
	
	def private String genRecvPortInitializer(Root root, ActorInstance ai, InterfaceItemInstance pi) {
		if (pi.peers.empty)
			return "{NULL}"

		var peer = pi.peers.get(0)
		var peerInst = pi.peers.get(0).eContainer() as ActorInstance
		var instName = peerInst.path.pathName
			
		"{&"+instName+"."+peer.name+"}"
	}
	
	def private String genReplSubPortInitializers(Root root, ActorInstance ai, InterfaceItemInstance pi) {
		var result = ""
		
		for (p: pi.peers) {
			val idx = pi.peers.indexOf(p)
			val comma = if (idx<pi.peers.size-1) "," else ""
			val thread = ETMapUtil::getPhysicalThread(p.eContainer as ActorInstance).name
			var iiiD = getInterfaceItemInstanceData(pi)
			iiiD = if (iiiD.equals("0")) iiiD+"," else iiiD+"["+idx+"],"
			result = result +
				"{"+iiiD 
				+"&msgService_"+thread+", "
				+p.objId+", "
				+(root.getExpandedActorClass(ai).getInterfaceItemLocalId(pi.interfaceItem)+1)+", "
				+idx
				+"}"+comma+" /* Repl Sub Port "+pi.name+" idx +"+idx+"*/\n"
		}
		
		return result
	}
	
	def private generateDispatcherFile(Root root, SubSystemInstance ssi) {
	val nr = ETMapUtil::getNodeRef(ssi)
	'''
		/**
		 * @author generated by eTrice
		 *
		 * Dispatcher File of Node «nr.name» with SubSystem «ssi.name»
		 * - one generated dispatcher for each MessageService (Thread)
		 */
		
		#include "messaging/etMessageReceiver.h"
		#include "debugging/etLogger.h"
		#include "debugging/etMSCLogger.h"
		
		«FOR thread: nr.type.threads SEPARATOR "\n"»
			static void MsgDispatcher_«thread.name»_receiveMessage(const etMessage* msg){
				ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_«thread.name»", "receiveMessage")
				switch(msg->address){
				
					«FOR ai : ssi.allContainedInstances.filter(ai|ETMapUtil::getPhysicalThread(ai)==thread)»
						/* interface items of «ai.path» */
						«FOR pi : ai. orderedIfItemInstances.filter(p|p.protocol.commType==CommunicationType::EVENT_DRIVEN)»
							«IF pi.replicated»
								«FOR peer: pi.peers»
									case «pi.objId+pi.peers.indexOf(peer)»:
										«IF (pi.protocol.handlesReceive(pi.isConjugated()))»
											switch (msg->evtID){
												«FOR h:getReceiveHandlers(pi.protocol,pi.isConjugated())»
													case «pi.protocol.name»_«h.msg.codeName»:
														«pi.protocol.getPortClassName(pi.isConjugated)»_«h.msg.name»_receiveHandler((etPort *)&«ai.path.pathName»_const.«pi.name».ports[«pi.peers.indexOf(peer)»],msg,(void*)&«ai.path.pathName»,«ai.actorClass.name»_receiveMessage);
													break;
												«ENDFOR»
												default: «ai.actorClass.name»_receiveMessage((void*)&«ai.path.pathName»,(etPort*)&«ai.path.pathName»_const.«pi.name».ports[«pi.peers.indexOf(peer)»], msg);
												break;
												}										
										«ELSE»
											«ai.actorClass.name»_receiveMessage((void*)&«ai.path.pathName»,(etPort*)&«ai.path.pathName»_const.«pi.name».ports[«pi.peers.indexOf(peer)»], msg);
										«ENDIF»
									break;
								«ENDFOR»
							«ELSE»
								case «pi.objId»:
								«IF (pi.protocol.handlesReceive(pi.isConjugated()))» 
									switch (msg->evtID){
									«FOR h:getReceiveHandlers(pi.protocol,pi.isConjugated())»
										case «pi.protocol.name»_«h.msg.codeName»:
											«pi.protocol.getPortClassName(pi.isConjugated)»_«h.msg.name»_receiveHandler((etPort *)&«ai.path.pathName»_const.«pi.name»,msg,(void*)&«ai.path.pathName»,«ai.actorClass.name»_receiveMessage);
										break;
									«ENDFOR»
									default: «ai.actorClass.name»_receiveMessage((void*)&«ai.path.pathName»,(etPort*)&«ai.path.pathName»_const.«pi.name», msg);
									break;
									}
								«ELSE»
									«ai.actorClass.name»_receiveMessage((void*)&«ai.path.pathName»,(etPort*)&«ai.path.pathName»_const.«pi.name», msg);
								«ENDIF»
								break;
							«ENDIF»
						«ENDFOR»
					«ENDFOR»
					
					default:
						etLogger_logErrorF("MessageService_«thread.name»_receiveMessage: address %d does not exist ", msg->address);
					break;
				}
				ET_MSC_LOGGER_SYNC_EXIT
			}
		«ENDFOR»
		'''
	}
	
	def private generateDatadrivenExecutes(Root root, SubSystemInstance ssi) {'''
		«FOR ai : ssi.allContainedInstances»
			«IF ai.actorClass.commType == ActorCommunicationType::ASYNCHRONOUS || ai.actorClass.commType == ActorCommunicationType::DATA_DRIVEN»
				«ai.actorClass.name»_execute(&«ai.path.getPathName()»);
			«ENDIF»
		«ENDFOR»
	'''
	}
	
}
