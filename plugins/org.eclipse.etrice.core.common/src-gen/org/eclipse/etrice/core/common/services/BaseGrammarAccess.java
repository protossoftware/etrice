/*
 * generated by Xtext
 */
package org.eclipse.etrice.core.common.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class BaseGrammarAccess extends AbstractGrammarElementFinder {
	
	public class AnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.Annotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTypeAnnotationTypeCrossReference_1_0 = (CrossReference)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeAnnotationTypeFQNParserRuleCall_1_0_1 = (RuleCall)cTypeAnnotationTypeCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cAttributesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cAttributesKeyValueParserRuleCall_2_1_0 = (RuleCall)cAttributesAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cAttributesAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cAttributesKeyValueParserRuleCall_2_2_1_0 = (RuleCall)cAttributesAssignment_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		
		//// **************************************************************
		//// AnnotationType and Annotation Rules
		//Annotation:
		//	'@' type=[AnnotationType|FQN] ('(' attributes+=KeyValue (',' attributes+=KeyValue)* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//'@' type=[AnnotationType|FQN] ('(' attributes+=KeyValue (',' attributes+=KeyValue)* ')')?
		public Group getGroup() { return cGroup; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }
		
		//type=[AnnotationType|FQN]
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//[AnnotationType|FQN]
		public CrossReference getTypeAnnotationTypeCrossReference_1_0() { return cTypeAnnotationTypeCrossReference_1_0; }
		
		//FQN
		public RuleCall getTypeAnnotationTypeFQNParserRuleCall_1_0_1() { return cTypeAnnotationTypeFQNParserRuleCall_1_0_1; }
		
		//('(' attributes+=KeyValue (',' attributes+=KeyValue)* ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//attributes+=KeyValue
		public Assignment getAttributesAssignment_2_1() { return cAttributesAssignment_2_1; }
		
		//KeyValue
		public RuleCall getAttributesKeyValueParserRuleCall_2_1_0() { return cAttributesKeyValueParserRuleCall_2_1_0; }
		
		//(',' attributes+=KeyValue)*
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//','
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }
		
		//attributes+=KeyValue
		public Assignment getAttributesAssignment_2_2_1() { return cAttributesAssignment_2_2_1; }
		
		//KeyValue
		public RuleCall getAttributesKeyValueParserRuleCall_2_2_1_0() { return cAttributesKeyValueParserRuleCall_2_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_3() { return cRightParenthesisKeyword_2_3; }
	}
	public class KeyValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.KeyValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeyIDTerminalRuleCall_0_0 = (RuleCall)cKeyAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueLiteralParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//KeyValue:
		//	key=ID '=' value=Literal;
		@Override public ParserRule getRule() { return rule; }
		
		//key=ID '=' value=Literal
		public Group getGroup() { return cGroup; }
		
		//key=ID
		public Assignment getKeyAssignment_0() { return cKeyAssignment_0; }
		
		//ID
		public RuleCall getKeyIDTerminalRuleCall_0_0() { return cKeyIDTerminalRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//value=Literal
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Literal
		public RuleCall getValueLiteralParserRuleCall_2_0() { return cValueLiteralParserRuleCall_2_0; }
	}
	public class AnnotationTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.AnnotationType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAnnotationTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDocuAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDocuDocumentationParserRuleCall_2_0 = (RuleCall)cDocuAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cTargetKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cEqualsSignKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Alternatives cAlternatives_6 = (Alternatives)cGroup.eContents().get(6);
		private final Assignment cTargetsAssignment_6_0 = (Assignment)cAlternatives_6.eContents().get(0);
		private final RuleCall cTargetsAnnotationTargetTypeParserRuleCall_6_0_0 = (RuleCall)cTargetsAssignment_6_0.eContents().get(0);
		private final Group cGroup_6_1 = (Group)cAlternatives_6.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_6_1_0 = (Keyword)cGroup_6_1.eContents().get(0);
		private final Assignment cTargetsAssignment_6_1_1 = (Assignment)cGroup_6_1.eContents().get(1);
		private final RuleCall cTargetsAnnotationTargetTypeParserRuleCall_6_1_1_0 = (RuleCall)cTargetsAssignment_6_1_1.eContents().get(0);
		private final Group cGroup_6_1_2 = (Group)cGroup_6_1.eContents().get(2);
		private final Keyword cCommaKeyword_6_1_2_0 = (Keyword)cGroup_6_1_2.eContents().get(0);
		private final Assignment cTargetsAssignment_6_1_2_1 = (Assignment)cGroup_6_1_2.eContents().get(1);
		private final RuleCall cTargetsAnnotationTargetTypeParserRuleCall_6_1_2_1_0 = (RuleCall)cTargetsAssignment_6_1_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6_1_3 = (Keyword)cGroup_6_1.eContents().get(3);
		private final Assignment cAttributesAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cAttributesAnnotationAttributeParserRuleCall_7_0 = (RuleCall)cAttributesAssignment_7.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//AnnotationType:
		//	'AnnotationType' name=ID docu=Documentation? '{'
		//	'target' '=' (targets+=AnnotationTargetType | '{' targets+=AnnotationTargetType (',' targets+=AnnotationTargetType)*
		//	'}') attributes+=AnnotationAttribute*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'AnnotationType' name=ID docu=Documentation? '{' 'target' '=' (targets+=AnnotationTargetType | '{'
		//targets+=AnnotationTargetType (',' targets+=AnnotationTargetType)* '}') attributes+=AnnotationAttribute* '}'
		public Group getGroup() { return cGroup; }
		
		//'AnnotationType'
		public Keyword getAnnotationTypeKeyword_0() { return cAnnotationTypeKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//docu=Documentation?
		public Assignment getDocuAssignment_2() { return cDocuAssignment_2; }
		
		//Documentation
		public RuleCall getDocuDocumentationParserRuleCall_2_0() { return cDocuDocumentationParserRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//'target'
		public Keyword getTargetKeyword_4() { return cTargetKeyword_4; }
		
		//'='
		public Keyword getEqualsSignKeyword_5() { return cEqualsSignKeyword_5; }
		
		//targets+=AnnotationTargetType | '{' targets+=AnnotationTargetType (',' targets+=AnnotationTargetType)* '}'
		public Alternatives getAlternatives_6() { return cAlternatives_6; }
		
		//targets+=AnnotationTargetType
		public Assignment getTargetsAssignment_6_0() { return cTargetsAssignment_6_0; }
		
		//AnnotationTargetType
		public RuleCall getTargetsAnnotationTargetTypeParserRuleCall_6_0_0() { return cTargetsAnnotationTargetTypeParserRuleCall_6_0_0; }
		
		//'{' targets+=AnnotationTargetType (',' targets+=AnnotationTargetType)* '}'
		public Group getGroup_6_1() { return cGroup_6_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_6_1_0() { return cLeftCurlyBracketKeyword_6_1_0; }
		
		//targets+=AnnotationTargetType
		public Assignment getTargetsAssignment_6_1_1() { return cTargetsAssignment_6_1_1; }
		
		//AnnotationTargetType
		public RuleCall getTargetsAnnotationTargetTypeParserRuleCall_6_1_1_0() { return cTargetsAnnotationTargetTypeParserRuleCall_6_1_1_0; }
		
		//(',' targets+=AnnotationTargetType)*
		public Group getGroup_6_1_2() { return cGroup_6_1_2; }
		
		//','
		public Keyword getCommaKeyword_6_1_2_0() { return cCommaKeyword_6_1_2_0; }
		
		//targets+=AnnotationTargetType
		public Assignment getTargetsAssignment_6_1_2_1() { return cTargetsAssignment_6_1_2_1; }
		
		//AnnotationTargetType
		public RuleCall getTargetsAnnotationTargetTypeParserRuleCall_6_1_2_1_0() { return cTargetsAnnotationTargetTypeParserRuleCall_6_1_2_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6_1_3() { return cRightCurlyBracketKeyword_6_1_3; }
		
		//attributes+=AnnotationAttribute*
		public Assignment getAttributesAssignment_7() { return cAttributesAssignment_7; }
		
		//AnnotationAttribute
		public RuleCall getAttributesAnnotationAttributeParserRuleCall_7_0() { return cAttributesAnnotationAttributeParserRuleCall_7_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_8() { return cRightCurlyBracketKeyword_8; }
	}
	public class AnnotationTargetTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.AnnotationTargetType");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		////
		//// Sub-grammars should use AnnotationTargetType to refer to 
		//// specific sub-grammar targets. For example, valid values for 
		//// AnnotationTargetType in the Room.xtext sub-grammar include "ActorClass", 
		//// "ActorBehavior", "ProtocolClass", etc. The sub-grammar is responsible for 
		//// implementing validation, quick-fixes, and code completion proposals via the 
		//// usual Xtext mechanisms.
		////
		//AnnotationTargetType:
		//	ID;
		@Override public ParserRule getRule() { return rule; }
		
		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}
	public class AnnotationAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.AnnotationAttribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSimpleAnnotationAttributeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumAnnotationAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AnnotationAttribute:
		//	SimpleAnnotationAttribute | EnumAnnotationAttribute;
		@Override public ParserRule getRule() { return rule; }
		
		//SimpleAnnotationAttribute | EnumAnnotationAttribute
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SimpleAnnotationAttribute
		public RuleCall getSimpleAnnotationAttributeParserRuleCall_0() { return cSimpleAnnotationAttributeParserRuleCall_0; }
		
		//EnumAnnotationAttribute
		public RuleCall getEnumAnnotationAttributeParserRuleCall_1() { return cEnumAnnotationAttributeParserRuleCall_1; }
	}
	public class SimpleAnnotationAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.SimpleAnnotationAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cOptionalAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final Keyword cOptionalOptionalKeyword_0_0_0 = (Keyword)cOptionalAssignment_0_0.eContents().get(0);
		private final Keyword cMandatoryKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cAttributeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeLiteralTypeEnumRuleCall_4_0 = (RuleCall)cTypeAssignment_4.eContents().get(0);
		
		//SimpleAnnotationAttribute:
		//	(optional?='optional' | 'mandatory') 'attribute' name=ID ':' type=LiteralType;
		@Override public ParserRule getRule() { return rule; }
		
		//(optional?='optional' | 'mandatory') 'attribute' name=ID ':' type=LiteralType
		public Group getGroup() { return cGroup; }
		
		//optional?='optional' | 'mandatory'
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//optional?='optional'
		public Assignment getOptionalAssignment_0_0() { return cOptionalAssignment_0_0; }
		
		//'optional'
		public Keyword getOptionalOptionalKeyword_0_0_0() { return cOptionalOptionalKeyword_0_0_0; }
		
		//'mandatory'
		public Keyword getMandatoryKeyword_0_1() { return cMandatoryKeyword_0_1; }
		
		//'attribute'
		public Keyword getAttributeKeyword_1() { return cAttributeKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//type=LiteralType
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }
		
		//LiteralType
		public RuleCall getTypeLiteralTypeEnumRuleCall_4_0() { return cTypeLiteralTypeEnumRuleCall_4_0; }
	}
	public class EnumAnnotationAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.EnumAnnotationAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cOptionalAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final Keyword cOptionalOptionalKeyword_0_0_0 = (Keyword)cOptionalAssignment_0_0.eContents().get(0);
		private final Keyword cMandatoryKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cAttributeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValuesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValuesSTRINGTerminalRuleCall_5_0 = (RuleCall)cValuesAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cCommaKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cValuesAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cValuesSTRINGTerminalRuleCall_6_1_0 = (RuleCall)cValuesAssignment_6_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//EnumAnnotationAttribute:
		//	(optional?='optional' | 'mandatory') 'attribute' name=ID ':' '{' values+=STRING (',' values+=STRING)* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//(optional?='optional' | 'mandatory') 'attribute' name=ID ':' '{' values+=STRING (',' values+=STRING)* '}'
		public Group getGroup() { return cGroup; }
		
		//optional?='optional' | 'mandatory'
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//optional?='optional'
		public Assignment getOptionalAssignment_0_0() { return cOptionalAssignment_0_0; }
		
		//'optional'
		public Keyword getOptionalOptionalKeyword_0_0_0() { return cOptionalOptionalKeyword_0_0_0; }
		
		//'mandatory'
		public Keyword getMandatoryKeyword_0_1() { return cMandatoryKeyword_0_1; }
		
		//'attribute'
		public Keyword getAttributeKeyword_1() { return cAttributeKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//values+=STRING
		public Assignment getValuesAssignment_5() { return cValuesAssignment_5; }
		
		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_5_0() { return cValuesSTRINGTerminalRuleCall_5_0; }
		
		//(',' values+=STRING)*
		public Group getGroup_6() { return cGroup_6; }
		
		//','
		public Keyword getCommaKeyword_6_0() { return cCommaKeyword_6_0; }
		
		//values+=STRING
		public Assignment getValuesAssignment_6_1() { return cValuesAssignment_6_1; }
		
		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_6_1_0() { return cValuesSTRINGTerminalRuleCall_6_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cImportedNamespaceAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cImportedNamespaceImportedFQNParserRuleCall_1_0_0_0 = (RuleCall)cImportedNamespaceAssignment_1_0_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cGroup_1_0.eContents().get(1);
		private final Keyword cFromKeyword_1_0_1_0 = (Keyword)cGroup_1_0_1.eContents().get(0);
		private final Assignment cImportURIAssignment_1_0_1_1 = (Assignment)cGroup_1_0_1.eContents().get(1);
		private final RuleCall cImportURISTRINGTerminalRuleCall_1_0_1_1_0 = (RuleCall)cImportURIAssignment_1_0_1_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cModelKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cImportURIAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cImportURISTRINGTerminalRuleCall_1_1_1_0 = (RuleCall)cImportURIAssignment_1_1_1.eContents().get(0);
		
		//// **************************************************************
		//// Import rules
		//// HOWTO: use a combination of URI global scopes and namespace aware local scope provider
		//// this is configured in the work flow by
		////			fragment = scoping.ImportURIScopingFragment {}
		//// and by overriding configureIScopeProviderDelegate in the runtime module with 
		////			ImportedNamespaceAwareLocalScopeProvider
		//// also configure in the RuntimeModule
		////	public Class<? extends ImportUriResolver> bindImportUriResolver() {
		////		return PlatformRelativeUriResolver.class;
		////	}
		//// and in the UiRuntimeModule
		////	public Class<? extends org.eclipse.xtext.ui.editor.IURIEditorOpener> bindIURIEditorOpener() {
		////		return GlobalNonPlatformURIEditorOpener.class;
		////	}
		////	public Class<? extends IHyperlinkHelper> bindIHyperlinkHelper() {
		////		return ImportAwareHyperlinkHelper.class;
		////	}
		//// the attribute 'importedNamespace' is picked up by the ImportedNamespaceAwareLocalScopeProvider
		//// the attribute 'importURI' is picked up by the ImportUriGlobalScopeProvider
		//Import:
		//	'import' (importedNamespace=ImportedFQN ('from' importURI=STRING)? | 'model' importURI=STRING);
		@Override public ParserRule getRule() { return rule; }
		
		//'import' (importedNamespace=ImportedFQN ('from' importURI=STRING)? | 'model' importURI=STRING)
		public Group getGroup() { return cGroup; }
		
		//'import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//importedNamespace=ImportedFQN ('from' importURI=STRING)? | 'model' importURI=STRING
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//importedNamespace=ImportedFQN ('from' importURI=STRING)?
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//importedNamespace=ImportedFQN
		public Assignment getImportedNamespaceAssignment_1_0_0() { return cImportedNamespaceAssignment_1_0_0; }
		
		//ImportedFQN
		public RuleCall getImportedNamespaceImportedFQNParserRuleCall_1_0_0_0() { return cImportedNamespaceImportedFQNParserRuleCall_1_0_0_0; }
		
		//('from' importURI=STRING)?
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//'from'
		public Keyword getFromKeyword_1_0_1_0() { return cFromKeyword_1_0_1_0; }
		
		//importURI=STRING
		public Assignment getImportURIAssignment_1_0_1_1() { return cImportURIAssignment_1_0_1_1; }
		
		//STRING
		public RuleCall getImportURISTRINGTerminalRuleCall_1_0_1_1_0() { return cImportURISTRINGTerminalRuleCall_1_0_1_1_0; }
		
		//'model' importURI=STRING
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'model'
		public Keyword getModelKeyword_1_1_0() { return cModelKeyword_1_1_0; }
		
		//importURI=STRING
		public Assignment getImportURIAssignment_1_1_1() { return cImportURIAssignment_1_1_1; }
		
		//STRING
		public RuleCall getImportURISTRINGTerminalRuleCall_1_1_1_0() { return cImportURISTRINGTerminalRuleCall_1_1_1_0; }
	}
	public class ImportedFQNElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.ImportedFQN");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFQNParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ImportedFQN:
		//	FQN '.*'?;
		@Override public ParserRule getRule() { return rule; }
		
		//FQN '.*'?
		public Group getGroup() { return cGroup; }
		
		//FQN
		public RuleCall getFQNParserRuleCall_0() { return cFQNParserRuleCall_0; }
		
		//'.*'?
		public Keyword getFullStopAsteriskKeyword_1() { return cFullStopAsteriskKeyword_1; }
	}
	public class DocumentationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.Documentation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDocumentationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLinesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLinesSTRINGTerminalRuleCall_2_0 = (RuleCall)cLinesAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// **************************************************************
		//// Documentation Rule
		//Documentation:
		//	{Documentation}
		//	'['
		//	lines+=STRING*
		//	']';
		@Override public ParserRule getRule() { return rule; }
		
		//{Documentation} '[' lines+=STRING* ']'
		public Group getGroup() { return cGroup; }
		
		//{Documentation}
		public Action getDocumentationAction_0() { return cDocumentationAction_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//lines+=STRING*
		public Assignment getLinesAssignment_2() { return cLinesAssignment_2; }
		
		//STRING
		public RuleCall getLinesSTRINGTerminalRuleCall_2_0() { return cLinesSTRINGTerminalRuleCall_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class TIMEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.TIME");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Keyword cSKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cMsKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Keyword cUsKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cINTTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Keyword cNsKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		
		//// **************************************************************
		//// Time Rule
		//TIME ecore::ELong:
		//	INT 's' | INT 'ms' | INT 'us' | INT 'ns';
		@Override public ParserRule getRule() { return rule; }
		
		//INT 's' | INT 'ms' | INT 'us' | INT 'ns'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT 's'
		public Group getGroup_0() { return cGroup_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0_0() { return cINTTerminalRuleCall_0_0; }
		
		//'s'
		public Keyword getSKeyword_0_1() { return cSKeyword_0_1; }
		
		//INT 'ms'
		public Group getGroup_1() { return cGroup_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1_0() { return cINTTerminalRuleCall_1_0; }
		
		//'ms'
		public Keyword getMsKeyword_1_1() { return cMsKeyword_1_1; }
		
		//INT 'us'
		public Group getGroup_2() { return cGroup_2; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2_0() { return cINTTerminalRuleCall_2_0; }
		
		//'us'
		public Keyword getUsKeyword_2_1() { return cUsKeyword_2_1; }
		
		//INT 'ns'
		public Group getGroup_3() { return cGroup_3; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_3_0() { return cINTTerminalRuleCall_3_0; }
		
		//'ns'
		public Keyword getNsKeyword_3_1() { return cNsKeyword_3_1; }
	}
	public class LiteralArrayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.LiteralArray");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLiteralsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLiteralsLiteralParserRuleCall_0_0 = (RuleCall)cLiteralsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cLiteralsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cLiteralsLiteralParserRuleCall_1_1_0 = (RuleCall)cLiteralsAssignment_1_1.eContents().get(0);
		
		//LiteralArray:
		//	literals+=Literal (',' literals+=Literal)*;
		@Override public ParserRule getRule() { return rule; }
		
		//literals+=Literal (',' literals+=Literal)*
		public Group getGroup() { return cGroup; }
		
		//literals+=Literal
		public Assignment getLiteralsAssignment_0() { return cLiteralsAssignment_0; }
		
		//Literal
		public RuleCall getLiteralsLiteralParserRuleCall_0_0() { return cLiteralsLiteralParserRuleCall_0_0; }
		
		//(',' literals+=Literal)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//literals+=Literal
		public Assignment getLiteralsAssignment_1_1() { return cLiteralsAssignment_1_1; }
		
		//Literal
		public RuleCall getLiteralsLiteralParserRuleCall_1_1_0() { return cLiteralsLiteralParserRuleCall_1_1_0; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNumberLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStringLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// Value Types for Attributes
		//Literal:
		//	BooleanLiteral | NumberLiteral | StringLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanLiteral | NumberLiteral | StringLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_0() { return cBooleanLiteralParserRuleCall_0; }
		
		//NumberLiteral
		public RuleCall getNumberLiteralParserRuleCall_1() { return cNumberLiteralParserRuleCall_1; }
		
		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_2() { return cStringLiteralParserRuleCall_2; }
	}
	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.BooleanLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBooleanLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cFalseKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Assignment cIsTrueAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final Keyword cIsTrueTrueKeyword_1_1_0 = (Keyword)cIsTrueAssignment_1_1.eContents().get(0);
		
		//BooleanLiteral:
		//	{BooleanLiteral} ('false' | isTrue?='true');
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanLiteral} ('false' | isTrue?='true')
		public Group getGroup() { return cGroup; }
		
		//{BooleanLiteral}
		public Action getBooleanLiteralAction_0() { return cBooleanLiteralAction_0; }
		
		//'false' | isTrue?='true'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'false'
		public Keyword getFalseKeyword_1_0() { return cFalseKeyword_1_0; }
		
		//isTrue?='true'
		public Assignment getIsTrueAssignment_1_1() { return cIsTrueAssignment_1_1; }
		
		//'true'
		public Keyword getIsTrueTrueKeyword_1_1_0() { return cIsTrueTrueKeyword_1_1_0; }
	}
	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.NumberLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRealLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//NumberLiteral:
		//	IntLiteral | RealLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//IntLiteral | RealLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntLiteral
		public RuleCall getIntLiteralParserRuleCall_0() { return cIntLiteralParserRuleCall_0; }
		
		//RealLiteral
		public RuleCall getRealLiteralParserRuleCall_1() { return cRealLiteralParserRuleCall_1; }
	}
	public class RealLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.RealLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRealLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueRealParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//RealLiteral:
		//	{RealLiteral} value=Real;
		@Override public ParserRule getRule() { return rule; }
		
		//{RealLiteral} value=Real
		public Group getGroup() { return cGroup; }
		
		//{RealLiteral}
		public Action getRealLiteralAction_0() { return cRealLiteralAction_0; }
		
		//value=Real
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//Real
		public RuleCall getValueRealParserRuleCall_1_0() { return cValueRealParserRuleCall_1_0; }
	}
	public class IntLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.IntLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueIntegerParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//IntLiteral:
		//	{IntLiteral} value=Integer;
		@Override public ParserRule getRule() { return rule; }
		
		//{IntLiteral} value=Integer
		public Group getGroup() { return cGroup; }
		
		//{IntLiteral}
		public Action getIntLiteralAction_0() { return cIntLiteralAction_0; }
		
		//value=Integer
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//Integer
		public RuleCall getValueIntegerParserRuleCall_1_0() { return cValueIntegerParserRuleCall_1_0; }
	}
	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.StringLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStringLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//StringLiteral:
		//	{StringLiteral} value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//{StringLiteral} value=STRING
		public Group getGroup() { return cGroup; }
		
		//{StringLiteral}
		public Action getStringLiteralAction_0() { return cStringLiteralAction_0; }
		
		//value=STRING
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0() { return cValueSTRINGTerminalRuleCall_1_0; }
	}
	public class IntegerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.Integer");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_0_1 = (Keyword)cAlternatives_0_0.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cHEXTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Integer ecore::ELong:
		//	('+' | '-')? INT | HEX;
		@Override public ParserRule getRule() { return rule; }
		
		//('+' | '-')? INT | HEX
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//('+' | '-')? INT
		public Group getGroup_0() { return cGroup_0; }
		
		//('+' | '-')?
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_0_0_0() { return cPlusSignKeyword_0_0_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_0_0_1() { return cHyphenMinusKeyword_0_0_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0_1() { return cINTTerminalRuleCall_0_1; }
		
		//HEX
		public RuleCall getHEXTerminalRuleCall_1() { return cHEXTerminalRuleCall_1; }
	}
	public class RealElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.Real");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDecimalParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDecimalExpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Real ecore::EDouble:
		//	Decimal | DecimalExp;
		@Override public ParserRule getRule() { return rule; }
		
		//Decimal | DecimalExp
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Decimal
		public RuleCall getDecimalParserRuleCall_0() { return cDecimalParserRuleCall_0; }
		
		///*DotDecimal | DecimalDot |*/ DecimalExp
		public RuleCall getDecimalExpParserRuleCall_1() { return cDecimalExpParserRuleCall_1; }
	}
	public class DecimalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.Decimal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cPlusSignKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//Decimal hidden():
		//	('+' | '-')? INT '.' INT;
		@Override public ParserRule getRule() { return rule; }
		
		//('+' | '-')? INT '.' INT
		public Group getGroup() { return cGroup; }
		
		//('+' | '-')?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_0_0() { return cPlusSignKeyword_0_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_0_1() { return cHyphenMinusKeyword_0_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_3() { return cINTTerminalRuleCall_3; }
	}
	public class DecimalExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.DecimalExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cPlusSignKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Keyword cEKeyword_4_0 = (Keyword)cAlternatives_4.eContents().get(0);
		private final Keyword cEKeyword_4_1 = (Keyword)cAlternatives_4.eContents().get(1);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Keyword cPlusSignKeyword_5_0 = (Keyword)cAlternatives_5.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_5_1 = (Keyword)cAlternatives_5.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		////DotDecimal hidden():
		////	('+' | '-')? '.' INT;
		////
		////DecimalDot hidden():
		////	('+' | '-')? INT '.';
		//DecimalExp hidden():
		//	('+' | '-')? INT '.' INT ('e' | 'E') ('+' | '-')? INT;
		@Override public ParserRule getRule() { return rule; }
		
		//('+' | '-')? INT '.' INT ('e' | 'E') ('+' | '-')? INT
		public Group getGroup() { return cGroup; }
		
		//('+' | '-')?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_0_0() { return cPlusSignKeyword_0_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_0_1() { return cHyphenMinusKeyword_0_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_3() { return cINTTerminalRuleCall_3; }
		
		//'e' | 'E'
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//'e'
		public Keyword getEKeyword_4_0() { return cEKeyword_4_0; }
		
		//'E'
		public Keyword getEKeyword_4_1() { return cEKeyword_4_1; }
		
		//('+' | '-')?
		public Alternatives getAlternatives_5() { return cAlternatives_5; }
		
		//'+'
		public Keyword getPlusSignKeyword_5_0() { return cPlusSignKeyword_5_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_5_1() { return cHyphenMinusKeyword_5_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_6() { return cINTTerminalRuleCall_6; }
	}
	public class FQNElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.FQN");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//FQN:
		//	ID ('.' ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('.' ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('.' ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	
	public class LiteralTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.LiteralType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBOOLEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBOOLPtBooleanKeyword_0_0 = (Keyword)cBOOLEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cINTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cINTPtIntegerKeyword_1_0 = (Keyword)cINTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cREALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cREALPtRealKeyword_2_0 = (Keyword)cREALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cCHAREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cCHARPtCharacterKeyword_3_0 = (Keyword)cCHAREnumLiteralDeclaration_3.eContents().get(0);
		
		//enum LiteralType:
		//	BOOL='ptBoolean' |
		//	INT='ptInteger' |
		//	REAL='ptReal' |
		//	CHAR='ptCharacter';
		public EnumRule getRule() { return rule; }
		
		//BOOL='ptBoolean' | INT='ptInteger' | REAL='ptReal' | CHAR='ptCharacter'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BOOL='ptBoolean'
		public EnumLiteralDeclaration getBOOLEnumLiteralDeclaration_0() { return cBOOLEnumLiteralDeclaration_0; }
		
		//'ptBoolean'
		public Keyword getBOOLPtBooleanKeyword_0_0() { return cBOOLPtBooleanKeyword_0_0; }
		
		//INT='ptInteger'
		public EnumLiteralDeclaration getINTEnumLiteralDeclaration_1() { return cINTEnumLiteralDeclaration_1; }
		
		//'ptInteger'
		public Keyword getINTPtIntegerKeyword_1_0() { return cINTPtIntegerKeyword_1_0; }
		
		//REAL='ptReal'
		public EnumLiteralDeclaration getREALEnumLiteralDeclaration_2() { return cREALEnumLiteralDeclaration_2; }
		
		//'ptReal'
		public Keyword getREALPtRealKeyword_2_0() { return cREALPtRealKeyword_2_0; }
		
		//CHAR='ptCharacter'
		public EnumLiteralDeclaration getCHAREnumLiteralDeclaration_3() { return cCHAREnumLiteralDeclaration_3; }
		
		//'ptCharacter'
		public Keyword getCHARPtCharacterKeyword_3_0() { return cCHARPtCharacterKeyword_3_0; }
	}
	
	private final AnnotationElements pAnnotation;
	private final KeyValueElements pKeyValue;
	private final AnnotationTypeElements pAnnotationType;
	private final AnnotationTargetTypeElements pAnnotationTargetType;
	private final AnnotationAttributeElements pAnnotationAttribute;
	private final SimpleAnnotationAttributeElements pSimpleAnnotationAttribute;
	private final EnumAnnotationAttributeElements pEnumAnnotationAttribute;
	private final ImportElements pImport;
	private final ImportedFQNElements pImportedFQN;
	private final DocumentationElements pDocumentation;
	private final TIMEElements pTIME;
	private final LiteralTypeElements eLiteralType;
	private final LiteralArrayElements pLiteralArray;
	private final LiteralElements pLiteral;
	private final BooleanLiteralElements pBooleanLiteral;
	private final NumberLiteralElements pNumberLiteral;
	private final RealLiteralElements pRealLiteral;
	private final IntLiteralElements pIntLiteral;
	private final StringLiteralElements pStringLiteral;
	private final IntegerElements pInteger;
	private final RealElements pReal;
	private final DecimalElements pDecimal;
	private final DecimalExpElements pDecimalExp;
	private final FQNElements pFQN;
	private final TerminalRule tHEX;
	private final TerminalRule tCC_STRING;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public BaseGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pAnnotation = new AnnotationElements();
		this.pKeyValue = new KeyValueElements();
		this.pAnnotationType = new AnnotationTypeElements();
		this.pAnnotationTargetType = new AnnotationTargetTypeElements();
		this.pAnnotationAttribute = new AnnotationAttributeElements();
		this.pSimpleAnnotationAttribute = new SimpleAnnotationAttributeElements();
		this.pEnumAnnotationAttribute = new EnumAnnotationAttributeElements();
		this.pImport = new ImportElements();
		this.pImportedFQN = new ImportedFQNElements();
		this.pDocumentation = new DocumentationElements();
		this.pTIME = new TIMEElements();
		this.eLiteralType = new LiteralTypeElements();
		this.pLiteralArray = new LiteralArrayElements();
		this.pLiteral = new LiteralElements();
		this.pBooleanLiteral = new BooleanLiteralElements();
		this.pNumberLiteral = new NumberLiteralElements();
		this.pRealLiteral = new RealLiteralElements();
		this.pIntLiteral = new IntLiteralElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pInteger = new IntegerElements();
		this.pReal = new RealElements();
		this.pDecimal = new DecimalElements();
		this.pDecimalExp = new DecimalExpElements();
		this.pFQN = new FQNElements();
		this.tHEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.HEX");
		this.tCC_STRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.etrice.core.common.Base.CC_STRING");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.eclipse.etrice.core.common.Base".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// **************************************************************
	//// AnnotationType and Annotation Rules
	//Annotation:
	//	'@' type=[AnnotationType|FQN] ('(' attributes+=KeyValue (',' attributes+=KeyValue)* ')')?;
	public AnnotationElements getAnnotationAccess() {
		return pAnnotation;
	}
	
	public ParserRule getAnnotationRule() {
		return getAnnotationAccess().getRule();
	}
	
	//KeyValue:
	//	key=ID '=' value=Literal;
	public KeyValueElements getKeyValueAccess() {
		return pKeyValue;
	}
	
	public ParserRule getKeyValueRule() {
		return getKeyValueAccess().getRule();
	}
	
	//AnnotationType:
	//	'AnnotationType' name=ID docu=Documentation? '{'
	//	'target' '=' (targets+=AnnotationTargetType | '{' targets+=AnnotationTargetType (',' targets+=AnnotationTargetType)*
	//	'}') attributes+=AnnotationAttribute*
	//	'}';
	public AnnotationTypeElements getAnnotationTypeAccess() {
		return pAnnotationType;
	}
	
	public ParserRule getAnnotationTypeRule() {
		return getAnnotationTypeAccess().getRule();
	}
	
	////
	//// Sub-grammars should use AnnotationTargetType to refer to 
	//// specific sub-grammar targets. For example, valid values for 
	//// AnnotationTargetType in the Room.xtext sub-grammar include "ActorClass", 
	//// "ActorBehavior", "ProtocolClass", etc. The sub-grammar is responsible for 
	//// implementing validation, quick-fixes, and code completion proposals via the 
	//// usual Xtext mechanisms.
	////
	//AnnotationTargetType:
	//	ID;
	public AnnotationTargetTypeElements getAnnotationTargetTypeAccess() {
		return pAnnotationTargetType;
	}
	
	public ParserRule getAnnotationTargetTypeRule() {
		return getAnnotationTargetTypeAccess().getRule();
	}
	
	//AnnotationAttribute:
	//	SimpleAnnotationAttribute | EnumAnnotationAttribute;
	public AnnotationAttributeElements getAnnotationAttributeAccess() {
		return pAnnotationAttribute;
	}
	
	public ParserRule getAnnotationAttributeRule() {
		return getAnnotationAttributeAccess().getRule();
	}
	
	//SimpleAnnotationAttribute:
	//	(optional?='optional' | 'mandatory') 'attribute' name=ID ':' type=LiteralType;
	public SimpleAnnotationAttributeElements getSimpleAnnotationAttributeAccess() {
		return pSimpleAnnotationAttribute;
	}
	
	public ParserRule getSimpleAnnotationAttributeRule() {
		return getSimpleAnnotationAttributeAccess().getRule();
	}
	
	//EnumAnnotationAttribute:
	//	(optional?='optional' | 'mandatory') 'attribute' name=ID ':' '{' values+=STRING (',' values+=STRING)* '}';
	public EnumAnnotationAttributeElements getEnumAnnotationAttributeAccess() {
		return pEnumAnnotationAttribute;
	}
	
	public ParserRule getEnumAnnotationAttributeRule() {
		return getEnumAnnotationAttributeAccess().getRule();
	}
	
	//// **************************************************************
	//// Import rules
	//// HOWTO: use a combination of URI global scopes and namespace aware local scope provider
	//// this is configured in the work flow by
	////			fragment = scoping.ImportURIScopingFragment {}
	//// and by overriding configureIScopeProviderDelegate in the runtime module with 
	////			ImportedNamespaceAwareLocalScopeProvider
	//// also configure in the RuntimeModule
	////	public Class<? extends ImportUriResolver> bindImportUriResolver() {
	////		return PlatformRelativeUriResolver.class;
	////	}
	//// and in the UiRuntimeModule
	////	public Class<? extends org.eclipse.xtext.ui.editor.IURIEditorOpener> bindIURIEditorOpener() {
	////		return GlobalNonPlatformURIEditorOpener.class;
	////	}
	////	public Class<? extends IHyperlinkHelper> bindIHyperlinkHelper() {
	////		return ImportAwareHyperlinkHelper.class;
	////	}
	//// the attribute 'importedNamespace' is picked up by the ImportedNamespaceAwareLocalScopeProvider
	//// the attribute 'importURI' is picked up by the ImportUriGlobalScopeProvider
	//Import:
	//	'import' (importedNamespace=ImportedFQN ('from' importURI=STRING)? | 'model' importURI=STRING);
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//ImportedFQN:
	//	FQN '.*'?;
	public ImportedFQNElements getImportedFQNAccess() {
		return pImportedFQN;
	}
	
	public ParserRule getImportedFQNRule() {
		return getImportedFQNAccess().getRule();
	}
	
	//// **************************************************************
	//// Documentation Rule
	//Documentation:
	//	{Documentation}
	//	'['
	//	lines+=STRING*
	//	']';
	public DocumentationElements getDocumentationAccess() {
		return pDocumentation;
	}
	
	public ParserRule getDocumentationRule() {
		return getDocumentationAccess().getRule();
	}
	
	//// **************************************************************
	//// Time Rule
	//TIME ecore::ELong:
	//	INT 's' | INT 'ms' | INT 'us' | INT 'ns';
	public TIMEElements getTIMEAccess() {
		return pTIME;
	}
	
	public ParserRule getTIMERule() {
		return getTIMEAccess().getRule();
	}
	
	//enum LiteralType:
	//	BOOL='ptBoolean' |
	//	INT='ptInteger' |
	//	REAL='ptReal' |
	//	CHAR='ptCharacter';
	public LiteralTypeElements getLiteralTypeAccess() {
		return eLiteralType;
	}
	
	public EnumRule getLiteralTypeRule() {
		return getLiteralTypeAccess().getRule();
	}
	
	//LiteralArray:
	//	literals+=Literal (',' literals+=Literal)*;
	public LiteralArrayElements getLiteralArrayAccess() {
		return pLiteralArray;
	}
	
	public ParserRule getLiteralArrayRule() {
		return getLiteralArrayAccess().getRule();
	}
	
	//// Value Types for Attributes
	//Literal:
	//	BooleanLiteral | NumberLiteral | StringLiteral;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//BooleanLiteral:
	//	{BooleanLiteral} ('false' | isTrue?='true');
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return pBooleanLiteral;
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}
	
	//NumberLiteral:
	//	IntLiteral | RealLiteral;
	public NumberLiteralElements getNumberLiteralAccess() {
		return pNumberLiteral;
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}
	
	//RealLiteral:
	//	{RealLiteral} value=Real;
	public RealLiteralElements getRealLiteralAccess() {
		return pRealLiteral;
	}
	
	public ParserRule getRealLiteralRule() {
		return getRealLiteralAccess().getRule();
	}
	
	//IntLiteral:
	//	{IntLiteral} value=Integer;
	public IntLiteralElements getIntLiteralAccess() {
		return pIntLiteral;
	}
	
	public ParserRule getIntLiteralRule() {
		return getIntLiteralAccess().getRule();
	}
	
	//StringLiteral:
	//	{StringLiteral} value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	//Integer ecore::ELong:
	//	('+' | '-')? INT | HEX;
	public IntegerElements getIntegerAccess() {
		return pInteger;
	}
	
	public ParserRule getIntegerRule() {
		return getIntegerAccess().getRule();
	}
	
	//Real ecore::EDouble:
	//	Decimal | DecimalExp;
	public RealElements getRealAccess() {
		return pReal;
	}
	
	public ParserRule getRealRule() {
		return getRealAccess().getRule();
	}
	
	//Decimal hidden():
	//	('+' | '-')? INT '.' INT;
	public DecimalElements getDecimalAccess() {
		return pDecimal;
	}
	
	public ParserRule getDecimalRule() {
		return getDecimalAccess().getRule();
	}
	
	////DotDecimal hidden():
	////	('+' | '-')? '.' INT;
	////
	////DecimalDot hidden():
	////	('+' | '-')? INT '.';
	//DecimalExp hidden():
	//	('+' | '-')? INT '.' INT ('e' | 'E') ('+' | '-')? INT;
	public DecimalExpElements getDecimalExpAccess() {
		return pDecimalExp;
	}
	
	public ParserRule getDecimalExpRule() {
		return getDecimalExpAccess().getRule();
	}
	
	//FQN:
	//	ID ('.' ID)*;
	public FQNElements getFQNAccess() {
		return pFQN;
	}
	
	public ParserRule getFQNRule() {
		return getFQNAccess().getRule();
	}
	
	//terminal HEX:
	//	('0x' | '0X') ('0'..'9' | 'a'..'f' | 'A'..'F')+;
	public TerminalRule getHEXRule() {
		return tHEX;
	}
	
	//terminal CC_STRING:
	//	"'''"->"'''";
	public TerminalRule getCC_STRINGRule() {
		return tCC_STRING;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
